# HW 10

*Claudia Feng*

1. List all of the annotations you learned from class and homework to annotaitons.md

   

2. What is the authentication?

   Authentication is the process of confirming the identity of a person, device, or system. It's a critical element of many systems, especially in security, to ensure that only authorized entities have access to specific resources or information.

   

3. What is the authorization?

   Authorization is the process that comes after authentication. Once a system has confirmed the identity of a user (authentication), it then needs to determine what that user is allowed to do. That's what authorization is - the process of granting or denying access to specific resources or operations within a system based on the user's privileges.

   

4. What is the difference between authentication and authorization?

   1. **Authentication** is the process of verifying the identity of a person or system. It's about making sure that the person or system is who they say they are. This is often done through the use of usernames and passwords, but can also involve other methods like biometric data or possession of a specific device.

   2. **Authorization**, on the other hand, is the process that comes after authentication. Once a system knows who the user is (i.e., once the user is authenticated), it then needs to determine what the user is allowed to do. This is what authorization is: the process of granting or denying access to specific resources or operations within a system based on the user's privileges.

      

5. What is HTTP Session?

   **HTTP Session**: A session is a server-side storage of information that is desired to persist throughout the user's interaction with the web site or web application. Instead of storing large amounts of data in the user's browser, as in the case with cookies, only a unique identifier is stored on the client side (in a cookie usually), which is used to access the stored data on the server side. So, when a user visits a web page, a unique session ID is generated, which allows the server to track the state of that user.

   

6. What is Cookie?

   **Cookie**: A cookie is a small piece of data that a server sends to the user's web browser. The browser may store it and send it back with later requests to the same server. Typically, it's used to tell if two requests came from the same browser — keeping a user logged-in, for example. It remembers stateful information for the stateless HTTP protocol. Cookies can also be used for persistent client-side storage of data.

   

7. What is the difference between Session and Cookie?

   - **Location of storage**: Sessions store data on the server side, while cookies store data on the client side (user's browser).

   - **Storage capacity**: Cookies can generally store up to 4KB of data, which is enough for a session ID or other small data needs. If you need to store a large amount of data, sessions would be more appropriate.

   - **Security**: Since session data is stored on the server, it's generally more secure than cookie-based storage. Cookies can be vulnerable to theft, as the data is transmitted with each HTTP request.

   - **Lifespan**: Session data is deleted when the user closes the specific browser session (although this can be changed). Cookies, on the other hand, can persist across multiple sessions and have expiration dates set.

     

8. How do we use session and cookie to keep user information across the the application?

   1. **User Login**: When a user logs into an application, their credentials are sent to the server.

   2. **Authentication**: The server verifies the credentials. If they're valid, the server will create a new session for that user.

   3. **Creating a Session**: The server will generate a unique session ID for this new session and store it, along with any user data that should be persisted (like the user's ID, roles, preferences, etc.), in server-side storage.

   4. **Setting a Cookie**: The server then sends a response back to the client with a Set-Cookie header containing the unique session ID.

   5. **Storing the Cookie**: The client's web browser receives this response and stores the cookie with the session ID locally.

   6. **Subsequent Requests**: For each subsequent request to the server, the browser automatically includes all stored cookies for this domain in the request headers. This includes the cookie with our session ID.

   7. **Identifying the User**: When the server receives a request, it can look at the session ID in the cookie, and find the matching session in its server-side storage. This allows it to know who the user is and what they're allowed to do.

   8. **User Logout/Session Expiry**: When the user logs out or after a certain period of inactivity, the server invalidates the session, and the client deletes the cookie.

      

9. What is JWT?

   JWT stands for JSON Web Token. It's a compact, URL-safe means of representing claims to be transferred between two parties. The claims in a JWT are encoded as a JSON object that is used as the payload of a JSON Web Signature (JWS) structure or as the plaintext of a JSON Web Encryption (JWE) structure, enabling the claims to be digitally signed or integrity protected with a Message Authentication Code (MAC) and/or encrypted.

   A JWT is typically composed of three parts:

   1. **Header**: The header typically consists of two parts: the type of the token, which is JWT, and the signing algorithm being used, such as HMAC SHA256 or RSA.

   2. **Payload**: The second part of the token is the payload, which contains the claims. Claims are statements about an entity (typically, the user) and additional data. There are three types of claims: registered, public, and private claims.

   3. **Signature**: To create the signature part, you have to take the encoded header, the encoded payload, a secret, the algorithm specified in the header, and sign that.

      

10. What is the spring security filter?

    Spring Security is a powerful and highly customizable authentication and access-control framework for Java applications, particularly for Spring-based applications. It provides protection against attacks like session fixation, clickjacking, cross-site request forgery, etc.

    Spring Security uses a filter-based approach to apply security to the applications. The Spring Security Filter Chain is essentially a chain of filters that Spring Security uses to provide various security features.

    

11. decribe how do JWT work(slides 里有图， 26页)

    1. User provides info for authentication(userid, password, ..)

    2. Server does authentication

    3. Server creates a JWT

    4. Server sends the JWT to client

    5. JWT saved on client side

    6. Client sends JWT to server in request header

       

12. Do you use any Encoder to encode Password?

    Yes, hashing and salting.

    

13. What is UserDetailService? AuthenticationProvider?AuthenticationManager? AuthenticationFilter?(把这几个名字看熟悉也行)

    1. **UserDetailsService**: This is an interface with a single method `loadUserByUsername(String)`. The primary purpose of this interface is to allow Spring Security to load details about the user (like username, password, and granted authorities) given a username. The returned `UserDetails` object can then be used by Spring Security to perform various authentication and role-based access control checks.

    2. **AuthenticationProvider**: This interface represents an object capable of authenticating an authentication request. It has a single method `authenticate(Authentication)`, which takes an `Authentication` object and returns a fully populated `Authentication` object if it can authenticate the request; otherwise, it returns null. The `Authentication` object represents the principal (usually, a user) requesting authentication and their credentials (like username and password).

    3. **AuthenticationManager**: This is an interface that represents an object capable of handling an authentication request. It has a single method `authenticate(Authentication)`. `AuthenticationManager` can have one or more `AuthenticationProvider` objects to delegate the authentication process. `ProviderManager` is a common implementation of `AuthenticationManager` that delegates to a chain of `AuthenticationProvider` instances.

    4. **AuthenticationFilter**: Spring Security uses a filter-based approach, and several authentication mechanisms are implemented as filters that process specific types of authentication requests. Examples of authentication filters include `UsernamePasswordAuthenticationFilter`, `BasicAuthenticationFilter`, and `OAuth2LoginAuthenticationFilter`. These filters extract credentials from the request (such as username/password, an HTTP Basic header, or an OAuth2 authorization code), attempt to authenticate the user with the supplied credentials, and if successful, put an `Authentication` object representing the authenticated user in the `SecurityContext`.

       

14. What is the disadvantage of Session? how to overcome the disadvantage?

    1. **Scalability Issues**: When a server stores sessions for each user, it can consume significant amounts of memory, especially for applications with many users. This can become a problem as your application scales and needs to handle more users.
    2. **Load Balancing Challenges**: If you have a load balancer distributing requests across multiple servers, you'll have to implement some way to ensure that all requests from a particular user go to the same server (session affinity or sticky sessions), or you'll need to share session data between servers. Both can be challenging to implement correctly and efficiently.
    3. **Reliability**: If the server crashes, all session data stored in memory is lost. This could lead to poor user experiences.
    4. **Concurrency Issues**: If a user has multiple requests being processed at the same time, it can lead to race conditions in session data, where updates from one request overwrite updates from another.

    To overcome these issues, there are several strategies:

    1. **Session Replication**: In a multi-server environment, session data can be replicated across multiple servers. This can help to address both the load balancing and reliability issues, but it adds more network overhead and complexity.

    2. **Database or Distributed Storage**: Instead of storing session data in server memory, it can be stored in a database or a distributed storage system like Redis. This can help with scalability, load balancing, and reliability, but it may add latency to requests since you now have to make a network call to retrieve session data.

    3. **Stateless Authentication**: Instead of storing user data in a session, you could use a stateless authentication mechanism, like JWT (JSON Web Tokens). With JWT, the server doesn't store any user state. Instead, all the state is stored in the token itself, which is sent by the client with each request. This solves many of the issues with sessions, but has its own trade-offs (for example, it's harder to invalidate a JWT before it expires).

       

15. how to get value from application.properties?

    In Spring Boot, you can retrieve values from the `application.properties` file using the `@Value` annotation or by binding properties to an object using `@ConfigurationProperties`.

    1. **Using @Value annotation**

    The `@Value` annotation allows you to inject property values directly into fields, constructors, or methods. Here's how you could inject a property value into a field:

    ```java
    @Value("${property.name}")
    private String propertyName;
    ```

    In this case, `property.name` is the name of the property you want to inject.

    1. **Using @ConfigurationProperties**

    `@ConfigurationProperties` allows you to map a group of properties with a common prefix to a Java object. For instance:

    ```java
    @ConfigurationProperties(prefix = "property")
    public class MyProperties {
    
        private String name;
    
        // standard getters and setters
    }
    ```

    In this case, `property.name` from `application.properties` will be bound to the `name` field of the `MyProperties` object.

    

16. What is the role of configure(HttpSecurity http) and configure(AuthenticationManagerBuilder auth)?

    **configure(HttpSecurity http)**: This method is used for configuring web-based security for specific HTTP requests. By overriding it, you can customize the security settings with a fluent API. You can specify which URLs should be secured, which should be allowed for all, which authentication methods (like form login, basic auth, etc.) to use, CSRF protection settings, and more. 

    **configure(AuthenticationManagerBuilder auth)**: This method is used to establish an authentication mechanism by building an `AuthenticationManager`. You can set it up with in-memory users, LDAP authentication, JDBC authentication, custom UserDetailsService, and more.

    

17. What is Spring security authentication and authorization?

    In the context of Spring Security, authentication is about making sure the user is who they say they are, and authorization is about deciding what that user is allowed to do. Spring Security provides a comprehensive and extensible framework to handle both these aspects of security.

    

18. Assuming that the Redbook UI supports dark mode and multiple languages, when a user signs in, their preferences (such as dark-mode=true and lang=eng) will be read from the database. For the assignment, you can set a value like in the course materials; there is no need to actually read from a database. After signing in, observe the response header and cookie for related information. Continue calling other APIs and observe the request header or cookie for other information. After signing in, Spring Security will generate a session, and the JSESSIONID will be in the cookie. Try to obtain the session content through the JSESSIONID, and then log the session content using the log4j tool. Write the code based on the 08_04 branch.
     a. get cookie by **HttpServletRequest**

```java
@RestController
public class CookieController {
    @GetMapping("/read-cookie")
    public String
readCookie(HttpServletRequest request) {
        Cookie[] cookies =
request.getCookies();
        if (cookies != null) {
            for (Cookie cookie : cookies) {
if
("myCookie".equals(cookie.getName())) {
                    return "Cookie value: "
+ cookie.getValue();
                }
} }
        return "Cookie not found";
    }
}
```

b. Get cookie by **@RequestParam**

```java
@RestController
public class CookieController {
    @GetMapping("/read-cookie")
    public String
readCookie(@CookieValue(value = "myCookie",
required = false, defaultValue = "default-
value") String myCookie) {
return "Cookie value: " + myCookie;
	}
}
```

c. Get Session

```java
import java.util.Enumeration;
import javax.servlet.http.HttpSession;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import
org.springframework.web.bind.annotation.Get
Mapping;
import
org.springframework.web.bind.annotation.Res
tController;
@RestController
public class SessionController {
    private static final Logger logger =
LoggerFactory.getLogger(SessionController.c
lass);
    @GetMapping("/log-session")
    public String logSession(HttpSession
session) {
Enumeration<String> attributeNames
= session.getAttributeNames();
        logger.info("Session ID: {}",
session.getId());
while
(attributeNames.hasMoreElements()) {
            String attributeName =
attributeNames.nextElement();
            Object attributeValue =
session.getAttribute(attributeName);
            logger.info("Attribute: {} -
Value: {}", attributeName, attributeValue);
        }
        return "Session logged";
    }
}
```



19. Reading,泛读一下即可，自己觉得是重点的，可以多看两眼。https://www.intervi ewbit.com/spring-security-interview-questions/#is-security-a-cross-cutting-con cern

a. 1-12 b. 17 - 30