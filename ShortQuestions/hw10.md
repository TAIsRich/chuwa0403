## 1. List all of the annotations you learned from class and homework to annotaitons.md

1. @EnableWebSecurity: This annotation is used to enable Spring Security in your application.
2. @Secured: This annotation is used to define method-level security rules. You can specify one or more roles that are required to access the annotated method.
3. @PreAuthorize and @PostAuthorize: These annotations are used to define method-level security rules using SpEL expressions. @PreAuthorize is used to check security before the method is executed, while @PostAuthorize is used to check security after the method is executed.
4. @RolesAllowed: This annotation is used to specify the roles that are allowed to access a particular method or class.
5. @AuthenticationPrincipal: This annotation is used to inject the principal object of the currently authenticated user into a method parameter.
6. @SecuredProperty: This annotation is used to define security rules based on the values of properties in your application's configuration files.
7. @EnableGlobalMethodSecurity: This annotation is used to enable global method-level security in your application. It allows you to use @PreAuthorize, @PostAuthorize, and @Secured annotations across all of your application's classes and methods.

## 2. What is the authentication?

Authentication is the process of verifying the identity of a user or system. In the context of computer systems, authentication is typically used to grant access to a protected resource, such as a file, a network, or an application.Authentication can be achieved through various means, such as passwords, biometric authentication (e.g., fingerprint, facial recognition), security tokens (e.g., smart cards, USB tokens), and digital certificates. The purpose of authentication is to ensure that only authorized individuals or systems are granted access to the protected resource, and to prevent unauthorized access and potential security breaches.

## 3. What is the authorization?

Authorization is the process of determining what actions an authenticated user or system is allowed to perform on a particular resource. It is the next step after authentication, where the system checks whether the user or system has the necessary permissions to access or perform specific operations on the resource. Authorization can be granted based on various factors, such as user roles, access control lists (ACLs), and attributes of the resource being accessed. 
Authorization helps to ensure that only authorized users or systems can perform certain actions and that unauthorized access to resources is prevented. It is an essential aspect of maintaining the security and integrity of computer systems and networks.

## 4. What is the difference between authentication and authorization?

Authentication and authorization are two closely related but distinct concepts in computer security.

Authentication is the process of verifying the identity of a user or system. It is the process of confirming that the user or system is who it claims to be. Authentication is usually accomplished through a username and password, biometric authentication, security tokens, or digital certificates. Authorization, on the other hand, is the process of determining what actions an authenticated user or system is allowed to perform on a particular resource. It is the process of checking whether the user or system has the necessary permissions to access or perform specific operations on the resource.

Simply, authentication is about verifying the identity of a user or system, while authorization is about determining what the authenticated user or system is allowed to do.

## 5. What is HTTP Session?

An HTTP session is a way of maintaining state between a client and server over a series of HTTP requests and responses. In other words, it is a mechanism that enables the server to identify and track a user's interaction with a website or web application. HTTP sessions are particularly useful for web applications that require user authentication, as they enable the server to keep track of whether a user is logged in or not, and to restrict access to certain pages or features accordingly.

## 6. What is Cookie?

A cookie is a small piece of data that a website sends to a user's web browser, which is then stored on the user's computer or device. Cookies are used to remember information about the user's activity on the site, such as their preferences, login credentials, and shopping cart items. There are two types of cookies: session cookies and persistent cookies. Session cookies are temporary and are stored in the user's browser's memory until the browser is closed. Persistent cookies, on the other hand, are stored on the user's computer or device and remain there until they expire or are manually deleted. Cookies can be set by the website itself or by third-party services, such as advertising networks or social media platforms.

## 7. What is the difference between Session and Cookie?

A session is a way of maintaining state between a client and server over a series of HTTP requests and responses. It is a mechanism that enables the server to identify and track a user's interaction with a website or web application. Sessions are typically used to store information about the user's activity on the site, such as their login status, shopping cart items, and preferences. Sessions are stored on the server and are associated with a unique session ID that is sent to the client in a cookie.

A cookie is a small piece of data that a website sends to a user's web browser, which is then stored on the user's computer or device. Cookies are used to remember information about the user's activity on the site, such as their preferences, login credentials, and shopping cart items. Cookies are stored on the client's computer and are associated with a specific domain.

The main difference between sessions and cookies is where the data is stored. Session data is stored on the server, while cookie data is stored on the client's computer. Sessions are generally considered to be more secure than cookies, as they are not accessible to the client and can be encrypted and authenticated to prevent tampering.

## 8. How do we use session and cookie to keep user information across the the application?

Sessions and cookies are commonly used in web development to keep user information across the application.
When a user visits a website, the server can create a session for that user and store any relevant data in that session. For example, if the user logs in, the server can store the user's login credentials in the session. The session is associated with a unique session ID, which is typically stored in a cookie on the user's computer. As the user navigates through the website, the session ID cookie is sent with each request to the server. This allows the server to identify the user and retrieve the relevant session data. For example, if the user adds an item to their shopping cart, the server can store that item in the session. When the user navigates to the checkout page, the server can retrieve the items from the session and display them on the page. Cookies can also be used to store user preferences and settings, such as language preferences or theme choices. This allows the website to remember the user's preferences across multiple sessions.

## 9. What is JWT?

JWT stands for JSON Web Token, and it is a compact, URL-safe means of representing claims to be transferred between two parties. It is a commonly used method for securely transmitting information between parties in a web application environment.
A JWT consists of three parts: a header, a payload, and a signature. The header contains information about the type of token and the hashing algorithm used to create the signature. The payload contains the claims, or information, being transmitted in the token, such as user information or permissions. The signature is created using the header, payload, and a secret key, and is used to verify the authenticity of the token. JWTs are often used for authentication and authorization in web applications. When a user logs in, the server can generate a JWT containing the user's information and any necessary authorization details. The JWT can then be sent to the client, where it can be stored in local storage or a cookie. On subsequent requests, the client can send the JWT back to the server, which can use the signature to verify its authenticity and retrieve the user's information and authorization details from the payload.
JWTs have several advantages over traditional session-based authentication methods. They are stateless, meaning that the server does not need to keep track of session information, and they can be easily used in distributed environments and with APIs. However, they do require careful management of the secret key used to sign the tokens, as a compromised key could lead to the unauthorized access of sensitive information.

## 10. What is the spring security filter?

Spring Security is a popular authentication and authorization framework for Java web applications. The Spring Security filter is a key component of the framework, responsible for intercepting and processing incoming requests to ensure that the user is authenticated and authorized to access the requested resource. The Spring Security filter chain is composed of multiple filters, each responsible for a specific security task. These filters work together to provide a comprehensive security solution for the application.

Spring Security filter chain: 

1. Authentication filter: This filter is responsible for authenticating the user, typically by verifying a username and password. If the authentication is successful, the user is granted access to the requested resource.
2. Authorization filter: This filter is responsible for checking if the authenticated user has the necessary permissions to access the requested resource. If the user is not authorized, the filter can redirect them to a login page or display an error message.
3. CSRF filter: This filter protects against cross-site request forgery attacks by adding a unique token to each form submission. The filter then verifies that the token is present and valid on subsequent form submissions.
4. Session management filter: This filter manages the user's session, including creating and invalidating the session, and setting session timeouts.
5. Logout filter: This filter is responsible for logging out the user, typically by invalidating the session and redirecting the user to a logout page.

## 11. decribe how do JWT work

1. User logs in: When a user logs into a web application, the server creates a JSON Web Token (JWT) containing information about the user, such as their user ID and any relevant permissions.
2. Token sent to client: The server sends the JWT to the client, typically as a response to the login request.
3. Token stored by client: The client stores the JWT, often in a cookie or local storage. The client can then send the JWT with subsequent requests to the server.
4. Token verification: When the client sends a request to the server, the server retrieves the JWT from the request header or cookie, and verifies the token's authenticity using a secret key that was used to sign the token. If the token is valid, the server extracts the user information from the token and processes the request.
5. Token expiration: JWTs can be configured with an expiration time, after which they are no longer valid. If a client sends an expired JWT, the server will reject the request.
6. Token revocation: If a JWT is compromised or a user's permissions change, the server can revoke the JWT, typically by invalidating the secret key used to sign the token. Any subsequent requests using the revoked token will be rejected.

JWTs provide a secure way of transmitting user information between a client and server, without requiring the server to store any session information. They are commonly used in stateless API architectures and single-page applications, as well as in traditional web applications.

## 12. Do you use any Encoder to encode Password?

In Java, it is recommended to use a password encoder to securely store passwords in a database or other storage medium. The Spring Security framework provides a built-in PasswordEncoder interface with several implementation classes, such as BCryptPasswordEncoder, which uses a cryptographic hash function to encode passwords and salt values to protect against rainbow table attacks.

```java
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;

String password = "myPassword123";

BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder();

String encodedPassword = passwordEncoder.encode(password);

System.out.println(encodedPassword);
```
It's important to note that password encoding alone is not enough to secure a web application. Developers should also follow other security best practices, such as implementing secure authentication and authorization mechanisms, using HTTPS to encrypt data in transit, and regularly applying security updates and patches to the application and its dependencies.

## 13. What is UserDetailService? AuthenticationProvider? AuthenticationManager? AuthenticationFilter?

1. UserDetailService: This is an interface that provides user details, such as the user's password and authorities, to the Spring Security framework. It is typically implemented by the application to retrieve user information from a database or other storage medium. The UserDetailService is used by the AuthenticationProvider to authenticate users.
2. AuthenticationProvider: This is an interface that provides authentication logic to the Spring Security framework. It is responsible for authenticating users using credentials such as username and password, and verifying their authority to access protected resources. The AuthenticationProvider uses the UserDetailService to retrieve user information and the AuthenticationManager to manage the authentication process.
3. AuthenticationManager: This is an interface that manages the authentication process for the Spring Security framework. It is responsible for coordinating the authentication providers and verifying the authentication of the user. The AuthenticationManager uses the AuthenticationFilter to initiate the authentication process.
4. AuthenticationFilter: This is a filter provided by Spring Security that intercepts incoming requests and triggers the authentication process. It looks for credentials such as username and password in the request, passes them to the AuthenticationManager to authenticate the user, and then creates an authenticated session for the user. The AuthenticationFilter can be configured to work with different authentication mechanisms, such as form-based authentication, HTTP basic authentication, or token-based authentication using JWTs.

## 14. What is the disadvantage of Session? how to overcome the disadvantage?

One of the main disadvantages of using sessions in web applications is that they are stored on the server, which can lead to scalability issues when dealing with a large number of users. 

1. Session Replication: One way to overcome the scalability issue is to use session replication. This involves copying session data to multiple servers in a cluster so that if one server fails, the user's session can be resumed on another server. However, this approach can be resource-intensive and can lead to issues with synchronization and consistency.
2. Session Persistence: Another way to overcome the scalability issue is to use session persistence. This involves storing session data in a distributed cache or database, which can be accessed by multiple servers in a cluster. This approach reduces the load on individual servers and allows for more efficient use of resources.
3. Token-Based Authentication: Another approach to overcome the scalability issue is to use token-based authentication instead of session-based authentication. Token-based authentication involves issuing a token (such as a JWT) to the client upon successful authentication, which is then used to authenticate subsequent requests. Since the token is stored on the client side, there is no need to store session data on the server, which improves scalability.
4. Shorter Session Timeout: Another way to improve scalability with sessions is to use a shorter session timeout. This means that the session will expire after a shorter period of inactivity, reducing the amount of time that session data needs to be stored on the server. However, this approach can negatively impact the user experience if users are required to log in frequently.

## 15. How to get value from application.properties?

To get a value from the application.properties file in a Spring Boot application, you can use the @Value annotation or the Environment object.

```java
@Component
public class MyComponent {

    @Value("${my.property}")
    private String myProperty;

}
```

## 16. What is the role of configure(HttpSecurity http) and configure(AuthenticationManagerBuilder auth)?

In a Spring Security application, the configure(HttpSecurity http) and configure(AuthenticationManagerBuilder auth) methods are used to configure the security settings for the application. The configure(HttpSecurity http) method is used to configure the security rules that determine which users can access which resources in the application. This method typically includes calls to methods such as authorizeRequests(), formLogin(), and logout().

```java
@Configuration
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .authorizeRequests()
                .antMatchers("/public/**").permitAll()
                .antMatchers("/admin/**").hasRole("ADMIN")
                .anyRequest().authenticated()
                .and()
            .formLogin()
                .loginPage("/login")
                .defaultSuccessUrl("/home")
                .permitAll()
                .and()
            .logout()
                .logoutUrl("/logout")
                .logoutSuccessUrl("/login")
                .permitAll();
    }

}
```

The configure(AuthenticationManagerBuilder auth) method is used to configure the authentication mechanism used by the application. This typically involves specifying the user details service and password encoder to use for authentication.

```java
@Configuration
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Autowired
    private UserDetailsService userDetailsService;

    @Autowired
    private PasswordEncoder passwordEncoder;

    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.userDetailsService(userDetailsService).passwordEncoder(passwordEncoder);
    }

}
```

## 17. What is Spring security authentication and authorization?

Spring Security provides authentication and authorization features for web applications based on the Java platform.

Authentication refers to the process of verifying the identity of a user. In a Spring Security application, authentication typically involves verifying a user's username and password. Spring Security supports various authentication mechanisms, such as form-based authentication, HTTP Basic authentication, and JSON Web Tokens (JWT) authentication.
Authorization refers to the process of determining whether a user has permission to access a particular resource or perform a specific action. In a Spring Security application, authorization is typically based on the user's roles and permissions. Spring Security provides several mechanisms for defining access control rules, such as Ant-style path matching, SpEL expressions, and method-level security.

Implementation:
1. Configure the authentication mechanism: You need to configure the authentication mechanism used by the application, such as form-based authentication or JWT authentication. This typically involves configuring a user details service to load user information, a password encoder to hash passwords, and an authentication provider to authenticate users.
2. Configure the authorization rules: You need to configure the access control rules that determine which users can access which resources in the application. This typically involves defining access control rules based on URL patterns, roles, and permissions.
3. Implement user interfaces: You need to implement user interfaces, such as login and logout pages, to allow users to authenticate and log out of the application.

## 18. Assuming that the Redbook UI supports dark mode and multiple languages, when a user signs in, their preferences (such as dark-mode=true and lang=eng) will be read from the database. For the assignment, you can set a value like in the course materials; there is no need to actually read from a database. After signing in, observe the response header and cookie for related information. Continue calling other APIs and observe the request header or cookie for other information. After signing in, Spring Security will generate a session, and the JSESSIONID will be in the cookie. Try to obtain the session content through the JSESSIONID, and then log the session content using the log4j tool. Write the code based on the 08_04 branch.

### get cookie by HttpServletRequest

```java
@RestController
public class CookieController {
    @GetMapping("/read-cookie")
    public String readCookie(HttpServletRequest request) {
        Cookie[] cookies = request.getCookies();
        if (cookies != null) {
            for (Cookie c : cookies) {
                if ("myCookie".equals(cookie.getName())) {
                    return "Cookies value" + cookie.getValue();
                }
            }
        }
        return "Cookie not found";
    }
}

```
### Get cookie by @RequestParam
```java
@RestController
public class CookieController {
    @GetMapping("/read-cookie")
    public String readCookie(@CookieValue(value = "myCookie", required = false,
                                            defaultValue = "default-value") String myCookie) {
        return "Cookie value: " + myCookie;
    }
}
```

### Get Session
```java
@RestController
public class SessionController {
    
    private static final Logger logger = LoggerFactory.getLogger(SessionController.class);
    
    @GetMapping("/log-session")
    public String logSession(HttpSession httpSession) {
        Enumeration<String> attributeNames = session.getAttributeNames();
        logger.info(session.getId());
        while (attributesName.hasMoreElements()) {
            String attributeName = attributeNames.nextElement();
            Object attributeValue= session.getAttribute(attributeName);
            logger.info()
        }
        return "Session logged";
    }
}
```


