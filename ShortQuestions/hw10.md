## 1. List all of the annotations you learned from class and homework to annotaitons.md
check annotations.md

## 2. What is the authentication?
Authentication is the process of verifying the identity of a user or entity. It ensures that the user or entity is who they claim to be. In the context of a software system, authentication is typically performed by requesting and verifying credentials, such as a username and password, a token, or a digital certificate. The purpose of authentication is to establish trust and grant access to the system or its resources based on the verified identity.

## 3. What is the authorization?
Authorization is the process of determining what actions or resources a user or entity is allowed to access or perform within a software system. Once a user or entity is authenticated, authorization determines the permissions and privileges associated with their identity and enforces access control rules. These rules define what actions or resources are allowed or denied based on factors such as user roles, permissions, or other criteria. Authorization ensures that users can only access the parts of the system or resources they are authorized to use.

## 4. What is the difference between authentication and authorization?
Authentication verifies the identity of a user or entity, while authorization determines the access rights and permissions granted to that identity within a software system. These two concepts work together to ensure proper access control and security.

## 5. What is HTTP Session?
HTTP Session is a mechanism provided by the HTTP protocol and web servers to maintain stateful information between multiple requests and responses in a web application. It allows the server to associate a set of data with a specific client/browser for the duration of a session.

When a user accesses a web application, the server creates a unique session for that user and assigns a session ID, which is typically stored as a cookie in the user's browser. The session ID is then used to identify and retrieve the associated session data on subsequent requests.

The session data can contain any information that needs to be persisted across multiple requests, such as user authentication details, shopping cart items, or user preferences. The server stores this data on the server-side and associates it with the session ID.

## 6. What is Cookie?
A cookie is a small piece of data sent from a web server to a user's browser. The browser stores the cookie and sends it back with each subsequent request to the same server. This allows the server to identify and track users and remember their preferences or other data.

Cookies are produced by the web server and sent to the client through HTTP headers. When a browser receives a cookie, it stores it locally and includes it in future requests to the same server using the "Cookie" header.

You can find cookies in your browser's storage. In most browsers, you can access them through the browser's settings or developer tools under the "Application" or "Storage" tab.

## 7. What is the difference between Session and Cookie?
Sessions are a server-side mechanism for maintaining stateful information, while cookies are a client-side mechanism for storing small pieces of data. Sessions are more secure and suitable for storing sensitive information, while cookies are more convenient for storing small amounts of non-sensitive data on the client-side.

## 8. How do we use session and cookie to keep user information across the the application?
When calling the api, the server produce cookie and put the cookie to response header.
Front-end send a login request to the server, setting the user ID and preference cookies
Back-end set the cookies during the login process.
Front-end send a request to the server to get the user's profile data
Back-end read the cookies and use them to tailor the profile API response

## 9.  What is JWT?
JWT stands for JSON Web Token. It is a compact and self-contained way of transmitting information between parties as a JSON object. JWTs are commonly used for authentication and authorization purposes in web applications.

A JWT consists of three parts: header, payload, and signature. The header contains information about the type of token and the algorithm used for signing. The payload contains the claims, which are statements about the user and additional metadata. The signature is generated by combining the header, payload, and a secret key using the specified algorithm. The signature ensures the integrity and authenticity of the token.

## 10. What is the spring security filter?
The Spring Security filter is an essential component of the Spring Security framework, which provides powerful and flexible security features for Java applications. It is responsible for handling authentication and authorization processes, enforcing security rules, and protecting the application from various types of attacks.

The Spring Security filter is configured as part of the application's servlet filter chain. It intercepts incoming HTTP requests and applies security checks and actions based on the defined rules and configurations. The filter performs the following key tasks:

Authentication: The filter handles user authentication by verifying user credentials, such as username and password. It can support various authentication mechanisms, including form-based login, HTTP Basic authentication, and JSON Web Tokens (JWT).

Authorization: Once a user is authenticated, the filter enforces authorization rules to determine whether the user is allowed to access the requested resources or perform specific actions. It checks user roles, permissions, and other security attributes to make access control decisions.

Session Management: The filter manages user sessions, including session creation, expiration, and tracking. It can handle session-related tasks, such as invalidating sessions, preventing session fixation attacks, and managing session timeouts.

Cross-Site Request Forgery (CSRF) Protection: The filter helps prevent CSRF attacks by adding security tokens to requests and validating them on the server side.

Request and Response Filtering: The filter can inspect and modify the incoming requests and outgoing responses to implement additional security measures, such as header-based security, content filtering, and logging.

## 11. decribe how do JWT work(slides ⾥有图， 26页)
1 the client send POST request with username & password to the server for authentication.

2 the server validate the userinfo and generate the jwt using secret key.

3 the server return the generated jwt

4 the client sent other request with jwt in the header

5 the server validate the jwt using secret key

6 server return the response

## 12. Do you use any Encoder to encode Password?
BCryptPasswordEncoder: This is a widely used password encoder in Spring Security. It uses the BCrypt hashing algorithm, which incorporates a salt and multiple rounds of hashing to protect against brute-force attacks.

Argon2PasswordEncoder: Argon2 is a modern and memory-hard password hashing algorithm designed to resist various types of attacks, including GPU-based attacks. It provides a higher level of security compared to traditional algorithms like BCrypt.

Pbkdf2PasswordEncoder: PBKDF2 (Password-Based Key Derivation Function 2) is a widely used password hashing algorithm. It applies a pseudo-random function, such as HMAC, repeatedly to the password along with a salt and an iteration count to produce a derived key.

StandardPasswordEncoder: This is a simple password encoder that uses SHA-256 hashing algorithm with no additional salting or iteration. While it is not considered the most secure option, it can be used as a basic encoder in certain scenarios.

## 13. What is UserDetailService? AuthenticationProvider?AuthenticationManager? AuthenticationFilter?(把这⼏个名字看熟悉也⾏)
UserDetailsService: This interface is used to retrieve user details, such as username, password, and authorities, from a data source. It is responsible for loading user-specific data during the authentication process. You can implement this interface to customize how user details are retrieved, such as from a database, LDAP server, or any other source.

AuthenticationProvider: An AuthenticationProvider is responsible for authenticating a user based on the provided credentials. It performs the actual authentication process, including password validation, account status checks, and granting authorities. You can have multiple AuthenticationProviders in an application, each supporting a different authentication mechanism.

AuthenticationManager: The AuthenticationManager is responsible for orchestrating the authentication process. It delegates the authentication request to the appropriate AuthenticationProvider based on the configured authentication mechanism. It's typically used by the framework to handle authentication requests from the application.

AuthenticationFilter: An AuthenticationFilter is a Spring Security filter that intercepts incoming authentication requests and triggers the authentication process. It extracts the authentication credentials from the request, such as username and password, and passes them to the AuthenticationManager for authentication. The filter also handles successful and failed authentication attempts.

## 14. What is the disadvantage of Session? how to overcome the disadvantage?
Server Memory Usage: Sessions require server-side memory to store session data. If there are many active sessions, it can consume a significant amount of memory, leading to increased server resource usage. To overcome this, you can consider implementing session management strategies such as session timeout, session invalidation, and optimizing session data to minimize memory usage.

Scalability: Sessions are typically stored on a single server, which can become a bottleneck for scaling the application. As the number of concurrent users increases, it becomes challenging to distribute the session data across multiple servers. To address this, you can explore session clustering or session replication techniques that allow session data to be shared across multiple servers.

Serialization Overhead: Session data is typically serialized and deserialized for storage and retrieval. This process can introduce overhead, especially when dealing with large or complex objects. To mitigate this, consider optimizing the session data structure, using efficient serialization techniques, or storing only essential data in the session while offloading other data to external storage.

Client-Side Storage: Sessions are usually maintained on the server and identified by a session ID stored in a cookie or URL. This dependency on client-side storage can be a security concern, as cookies can be vulnerable to attacks such as session hijacking or cross-site scripting. To enhance security, you can implement secure session handling techniques, such as using secure cookies, encrypting session data, and implementing measures to prevent session-related attacks.

Statefulness: Sessions introduce statefulness to the application, as server-side data is maintained between requests. This can complicate the design and implementation of stateless architectures and make it harder to achieve RESTful principles. To address this, you can explore stateless authentication mechanisms like JSON Web Tokens (JWT), where session data is encoded within the token itself, eliminating the need for server-side storage.

## 15. how to get value from application.properties?
Using `@Value` annotation:

Add the `@Value` annotation to a field or method parameter in your component or configuration class.
Use the `#{}` syntax to reference the property key in the `application.properties` file.
Spring will automatically inject the value of the property into the annotated field or method parameter.
```java
@Value("${property.key}")
private String propertyValue;
```

Using `Environment` object:

Inject the `Environment` object into your component or configuration class.
Use the `getProperty()` method of the `Environment` object to retrieve the value of a property by specifying its key.
```java
@Autowired
private Environment environment;

public void someMethod() {
    String propertyValue = environment.getProperty("property.key");
}
```

Make sure that your `application.properties` file is located in the classpath and has the correct property keys and values.

Additionally, you can also use the `@ConfigurationProperties` annotation to bind a whole group of related properties to a Java object. This allows you to map multiple properties to fields or properties of the object automatically.
```java
@Configuration
@ConfigurationProperties("prefix")
public class MyConfiguration {
    private String property1;
    private String property2;

    // getters and setters
}
```
In the above example, properties with keys `prefix.property1` and `prefix.property2 `from `application.properties` will be automatically mapped to the `property1` and `property2` fields of the `MyConfiguration` class.



## 16. What is the role of configure(HttpSecurity http) and configure(AuthenticationManagerBuilder auth)?
`configure(HttpSecurity http)`:

This method is used to configure the security rules and access restrictions for different URLs or paths in your application.

It allows you to define authentication and authorization rules, specify which endpoints require authentication, and apply different security configurations based on the request patterns.

You can use various methods provided by the HttpSecurity object to define rules such as `authorizeRequests()`, `antMatchers()`, `authenticated()`, `permitAll()`, etc.

This method typically includes the configuration for form-based authentication, `OAuth`, `CSRF` protection, session management, and other security-related settings.
```java
@Override
protected void configure(HttpSecurity http) throws Exception {
    http
        .authorizeRequests()
            .antMatchers("/public/**").permitAll()
            .antMatchers("/admin/**").hasRole("ADMIN")
            .anyRequest().authenticated()
            .and()
        .formLogin()
            .loginPage("/login")
            .permitAll()
            .and()
        .logout()
            .logoutUrl("/logout")
            .permitAll();
}
```

`configure(AuthenticationManagerBuilder auth)`:

This method is used to configure the authentication mechanism for your application.
It allows you to define how user credentials are verified, where user information is stored (e.g., in-memory, database, LDAP), and how password encoding or hashing is performed.
You can use various methods provided by the AuthenticationManagerBuilder object to configure authentication providers, user details services, password encoders, etc.
This method typically includes the configuration for user authentication, such as defining user accounts, roles, and authentication mechanisms.
```java
@Override
protected void configure(AuthenticationManagerBuilder auth) throws Exception {
    auth
        .inMemoryAuthentication()
            .withUser("user1").password("{noop}password1").roles("USER")
            .and()
            .withUser("admin1").password("{noop}adminpass1").roles("ADMIN");
}
```

## 17. What is Spring security authentication and authorization?
`Authentication`:

Authentication is the process of verifying the identity of a user or entity.
Spring Security supports various authentication mechanisms such as `form-based authentication`, `HTTP Basic authentication`, `OAuth`, `LDAP authentication`, etc.
It provides an extensible framework to authenticate users against different sources like in-memory user details, databases, LDAP servers, or custom authentication providers.
During authentication, user credentials (e.g., username and password) are verified, and if successful, an authenticated user is granted access to protected resources.


`Authorization`:

Authorization is the process of granting or denying access to resources or functionalities based on the authenticated user's roles or permissions.
Spring Security allows you to define access control rules to protect different parts of your application.
You can specify which URLs or paths require authentication and authorization, and define role-based or permission-based access rules.
Spring Security supports method-level authorization, where you can apply access control restrictions to specific methods or service operations.
It provides annotations like `@Secured`, `@PreAuthorize`, and `@PostAuthorize` for fine-grained authorization.

## 18. Assuming that the Redbook UI supports dark mode and multiple languages, when a user signs in, their preferences (such as dark-mode=true and lang=eng) will be read from the database. For the assignment, you can set a value like in the course materials; there is no need to actually read from a database. After signing in, observe the response header and cookie for related information. Continue calling other APIs and observe the request header or cookie for other information. After signing in, Spring Security will generate a session, and the JSESSIONID will be in the cookie. Try to obtain the session content through the JSESSIONID, and then log the session content using the log4j tool. Write the code based on the 08_04 branch.
a. get cookie by HttpServletRequest
```java
@RestController
public class CookieController {
    @GetMapping("/read-cookie")
    public String readCookie(HttpServletRequest request) {
        Cookie[] cookies = request.getCookies();
        if (cookies != null) {
            for (Cookie cookie : cookies) {
                if("myCookie".equals(cookie.getName())) {
                    return "Cookie value: " + cookie.getValue();
                }
            }
        }
        return "Cookie not found";
    }
}
```


b. Get cookie by @RequestParam
```java
@RestController
public class CookieController {
    @GetMapping("/read-cookie")
    public String readCookie(@CookieValue(value = "myCookie",required = false, defaultValue = "defaultvalue") String myCookie) {
        return "Cookie value: " + myCookie;
    }
}
```

c. Get Session
```java
import java.util.Enumeration;
import javax.servlet.http.HttpSession;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;
@RestController
public class SessionController {
    private static final Logger logger = LoggerFactory.getLogger(SessionController.class);
    @GetMapping("/log-session")
    public String logSession(HttpSession session) {
        Enumeration<String> attributeNames = session.getAttributeNames();
        logger.info("Session ID: {}", session.getId());
        while (attributeNames.hasMoreElements()) {
            String attributeName = attributeNames.nextElement();
            Object attributeValue = session.getAttribute(attributeName);
            logger.info("Attribute: {} - Value: {}", attributeName, attributeValue);
        }
    return "Session logged";
    }
}

```


check folder Coding/hw10_q18

## 19. Reading, 泛读⼀下即可，⾃⼰觉得是重点的，可以多看两眼。https://www.interviewbit.com/spring-security-interview-questions/#is-security-a-cross-cutting-concern
a. 1-12
b. 17 - 30


