### 1.  List all of the annotations you learned from class and homework to annotaitons.md
### 2.  What is the authentication?
Authentication refers to the process of verifying the identity of a user. It involves validating users' credentials, like username and password.

### 3.  What is the authorization?
Authorization refers to the process of granting permissions to an authenticated user to perform certain actions or access specific resources

### 4.  What is the difference between authentication and authorization?
Authentication focuses on verifying the identification of a user while authorization focuses on determine whether a user has authority to access certain resources or perform specific actions.

### 5.  What is HTTP Session?
HTTP, by design, is stateless, which means each request is processed independently, without any stateful information been kept. HTTP session is server side storage mechanism used to maintain state across multiple requests from the same user. When a user logs into a web application or performs an action that requires state management, a session is created on the server. A unique session ID is generated and send to the client as cookie or sometimes as a part of URL. The server associates incoming requests of the same user or client with the correct session using the session ID.

### 6.  What is Cookie? 
A cookie is a small piece of data that a server sends to a user's browser. The browser stores and sends it back with subsequent requests to the same server. This allows the server to identify users or track stateful information during the conversation between client and server.

### 7. What is the difference between Session and Cookie?
1. Storage Location: Sessions are usually stored on the server, while Cookies are stored on the client's browser.
2. Capacity: Cookies have limited size usually 4KB. Sessions can store larger amounts of data than cookies.
3. Expiration: Cookie is usually deleted when the user closes the specific browser or expires  after a designated time period. Session persists even when the browser is closed and will be used in all future client requests until deleted or expired.
4. Security: Sessions are generally considered more secure than cookies because the session data resides on the server-side, while cookies are stored in the client's browser, they are potentially exposed to security risks. They can be intercepted or hijacked of sensitive information if transmitted over an unsecured connection. 

### 8.  How do we use session and cookie to keep user information across the the application?
**Session**

When a user logs in, the server implements authentication. If the credentials are valid, the server starts a new session for the user in server-side storage. The server generates a unique session ID for this session, returns and stores it in the cookies in the client-side. This cookie will then be included within every subsequent request from the client, allowing the server to use session ID to retrive associated session. Use the stateful information to personalize the client's behavior and implement access control throughout the user's session. When the user logs out or the session expires, the server deletes or invalidates the session.

**Cookies**

When a user logs in, store their relevant information in a cookie on the client-side. Every subsequent request will include the cookies. The server receives the cookie from the request headers and validates stateful information to implement access control. When the user logs out or the cookies expire, delete the cookie on the client-side.

### 9.  What is JWT?
JWT stands for JSON Web Token. It is a compact and self-contained way for securely transmitting information between between client and server. It is used for authenticatoin and authorization purposes in modern web application. It contains 3 parts:
1. Header: the type of the token (JWT), + algorithm being used (SHA256 or RSA).
2. Payload: statements about the user or other data.
3. Signature: combining the header, payload and a secret key to generate a signature.

### 10. What is the spring security filter?
In Spring Security, filters play a crucial role in the authentication and authorization process. Spring Security filter provides a set of pre-configured filters that intercept and process incoming HTTP requests and responses with security measures at various stages of the processing pipeline.

AuthenticationFilter: handles the authentication process, typically by inspecting the request for credentials (e.g., username/password or token) and verifying them against a user store or authentication provider.

AuthorizationFilter: checks whether the authenticated user has the necessary permissions to access the requested resource. It enforces access control rules based on roles, permissions, or other authorization mechanisms.

SessionManagementFilter: manages user sessions, handling tasks such as session creation, tracking, and expiration. It can also handle session fixation protection, concurrent session control, and other session-related security measures.

CsrfFilter: provides protection against Cross-Site Request Forgery (CSRF) attacks by adding and validating CSRF tokens in requests.

CorsFilter: handles Cross-Origin Resource Sharing (CORS) requests, enforcing security policies for cross-origin communication between a client and server.

LogoutFilter: handles the user logout process, clearing authentication-related information and performing any necessary cleanup tasks.

ExceptionTranslationFilter: catches and handles any exceptions that occur during the authentication or authorization process. It maps exceptions to appropriate error responses or redirects as configured.

### 11. decribe how do JWT work(slides 里有图， 26页)
1. When a user logs in, the server generates a JWT token that includes the user's details and other claims. This JWT is then signed by the server using a secret key or a public/private key pair. 
2. Then the JWT is sent back to the client and be stored in local storage or a cookie.
3. The subsequent requests include the JWT in the HTTP Authorization header. The server checks whether the signature of the JWT is valid, and extracts the payload of the JWT to identify the user and processes the request accordingly. Otherwise, the server rejects the request.
4. The server sets an expiration time on the JWT payload when it issues the token. If it expires, the server responds with an 'unauthorized' status, and the client must then obtain a new token.

### 12. Do you use any Encoder to encode Password?
1. BCryptPasswordEncoder: BCryptPasswordEncoder is a widely used password encoder in Spring Security. It uses the BCrypt hashing algorithm, which incorporates salting and multiple rounds of hashing to produce a strong, one-way hash, making it resistant to brute-force attacks.
2. Pbkdf2PasswordEncoder: Pbkdf2PasswordEncoder uses the PBKDF2 (Password-Based Key Derivation Function 2) algorithm to derive the hash. 
3. SCryptPasswordEncoder: SCryptPasswordEncoder is another password encoder in Spring Security that uses the scrypt algorithm.
4. StandardPasswordEncoder: This encoder implements a simple password hashing scheme based on SHA-256. While not as strong as the other encoders mentioned above, it can be useful for legacy systems or as a transitional step when migrating to stronger hashing algorithms.
5. Base64 is an encoding scheme rather than a password encoder specifically. It is commonly used for encoding binary data into a textual format that is safe for transmission over certain channels, such as email or HTTP headers, where only ASCII characters are allowed.

### 13. What is UserDetailService? AuthenticationProvider?AuthenticationManager AuthenticationFilter?(把这几个名字看熟悉也行)
UserDetailService: UserDetailsService is an interface provided by Spring Security that is used to retrieve user-specific data during the authentication process. It has a single method loadUserByUsername(), which is responsible for loading user details based on a given username. The implementation of UserDetailsService typically interacts with a data source (such as a database) to retrieve user information, including the user's password, roles, and other relevant data.

AutheticationProvider: AuthenticationProvider is an interface provided by the Spring Security framework. It is responsible for authenticating users' credentials and creating an Authentication object, which represents the user's authentication status and associated authorities (roles). The AuthenticationProvider interface defines a single method called authenticate(), which takes an Authentication object as input and returns a fully authenticated Authentication object. The authenticate() method performs the actual authentication process, including verifying the user's credentials, checking the user's account status, and assigning the appropriate authorities.

AuthenticationManager: AuthenticationManager is a core interface provided by the Spring Security framework. It is responsible for coordinating and managing the authentication process within an application. The AuthenticationManager acts as a central point for authenticating user credentials and delegating the authentication process to the configured AuthenticationProviders.

AuthenticationFilter: AuthenticationFilter is a component provided by the Spring Security framework that intercepts incoming requests and performs authentication for those requests. It is responsible for extracting the user's credentials from the request, authenticating the user, and generating an Authentication object that represents the authenticated user. AuthenticationFilter typically sits in the authentication processing chain and is configured to intercept specific URLs or request patterns. When a matching request is received, the filter extracts the necessary authentication information, such as username and password, from the request and creates an Authentication object. The AuthenticationFilter then delegates the authentication process to an AuthenticationManager to verify the user's credentials. If the authentication is successful, the filter creates a fully authenticated Authentication object and attaches it to the current security context.

### 14. What is the disadvantage of Session? how to overcome the disadvantage?
1. Memory Consumption: Sessions require storage on the server, which can be a concern if the server has limited storage capacity. This can be mitigated by configuring an appropriate session timeout or implementing a policy to regularly clean up old sessions.

2. Scalability: The more active users increase the number of active sessions, thus, the server needs to allocate more resources to handle and manage session data effectively. This can limit the scalability of the application. This can be solved by using a distributed session management system that stores session data across multiple servers, like Redis, or distributed caching systems.

3. Performance: Sessions require server-side storage and retrieval for each request, which can lead to overhead and impact performance, especially when the session data is large or complex.

4. Reliability: If the server crashes or restarts, all current sessions stored in memory will be lost. This can be solved by persisting sessions in an external store, like a database or a distributed cache.

5. Security: If a session ID is compromised (for instance session sniffing or session hijacking), an attacker can impersonate a user. This can be implement various security measures, like regenerating the session ID after login, encrypting session IDs when they are stored and transmitted, and implementing timeouts for inactive sessions.

6. Session affinity: In a clustered or load-balanced environment, to ensure the subsequent requests from the same client are directed to the same server (to maintain session continuity) can be challenging. Session affinity/sticky sessions which can limit scalability and increase complexity. To overcome this, you could use a shared session storage that all instances of your application can access, or synchronize sessions between your servers. Or we can use JWT.

### 15. how to get value from application.properties?
```
@Component
public class MyComponent {

    @Value("${my.property}")
    private String myProperty;

    // ...
}
```

### 16. What is the role of configure(HttpSecurity http) and configure(AuthenticationManagerBuilder auth)?
1. The configure(HttpSecurity http) method is used to configure the security aspects related to HTTP requests and resource access. It allows you to define rules and restrictions for different endpoints, specify access control, enable/disable security features, and customize various aspects of request handling. 
Within this method, you can use the http object to apply security configurations, such as: Defining authentication and authorization rules using methods like authorizeRequests(), antMatchers(), and authenticated(). 
Configuring form-based authentication using formLogin(). 
Configuring logout behavior using logout(). 
Enabling or disabling Cross-Site Request Forgery (CSRF) protection using csrf(). 
Configuring custom access denied handling using exceptionHandling(). 
Configuring session management using sessionManagement().

2. The configure(AuthenticationManagerBuilder auth) method is used to configure the authentication mechanism of your application. It allows you to define how user credentials are validated and retrieved during the authentication process. Within this method, you can use the auth object to specify authentication providers, user details services, password encoders, and other authentication-related configurations. Common configurations within this method include:
Defining user details services using userDetailsService() or inMemoryAuthentication().
Configuring password encoders using passwordEncoder().
Configuring authentication providers using authenticationProvider().
Applying custom authentication logic using authenticationProvider().

### 17.  What is Spring security authentication and authorization?
Authentication is the process of verifying the identity of a user.
During authentication, the user provides credentials (such as username and password, API token, or digital certificate) to prove their identity. Spring Security authenticates the user by validating the provided credentials against a user repository. Upon successful authentication, Spring Security establishes an authentication context that contains information about the authenticated user, such as their username, authorities, and authentication details. The authentication context is typically stored in the SecurityContextHolder and can be accessed throughout the application to determine the current user's identity.

Authorization is the process of determining whether an authenticated user has permission to perform specific actions or access certain resources within the application. Spring Security supports different ways of configuring access control, including annotations (@Secured, @PreAuthorize, @PostAuthorize), expression-based access control using SpEL (Spring Expression Language), and URL-based security configuration. The authorization process involves evaluating the user's authorities and the configured access control rules to decide whether access should be granted or denied. If access is denied, Spring Security provides mechanisms to handle access denied situations, such as redirecting the user to an error page or returning customized error messages.