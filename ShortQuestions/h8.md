# Part1. Spring database 1
# 1. List all of the annotations you learned from class and homework to annotaitons.md 
Please check in annotaitons.md

# 2. Type the Comment feature for the class project.
To store the comments in a database, you can use Spring Data JPA to define a repository interface for the Comment model. This interface can be used to perform CRUD (Create, Read, Update, Delete) operations on comments.

# 3. In postman, call of the APIs in PostController and CommentController. 
- Set the request method to the HTTP method (GET, POST, PUT, DELETE) that corresponds to the endpoint you want to call. 
- Enter the URL of the endpoint in the request URL field.  
- If necessary, set any headers or query parameters required by the endpoint.
- If the endpoint requires a request body (for example, when creating a new post or comment), select the "Body" tab and choose the appropriate content type (e.g. JSON) and enter the request body.
- Click "Send" to make the API call.
 - The response from the server will be displayed in the "Response" section of the Postman interface.

# 4. what is JPA? and what is Hibernate? 
JPA (Java Persistence API) is a specification for managing relational data in Java applications. It provides a set of standard interfaces and annotations for defining and working with persistent entities, as well as a set of APIs for querying and managing those entities.
Hibernate, on the other hand, is a popular implementation of the JPA specification. It provides a set of APIs for mapping Java objects to relational tables, as well as tools for managing the persistence lifecycle of those objects. Hibernate includes support for a variety of advanced features, such as lazy loading, caching, and optimistic locking.

# 5. What is Hiraki? what is the benefits of connection pool? 
"Hikari" is a popular connection pool library for Java applications.
A connection pool is a cache of database connections that can be reused by an application, instead of creating a new connection for every request. When an application needs to interact with a database, it can request a connection from the pool, use it to perform the necessary queries or updates, and then return the connection to the pool when it's done.

# 6. What is the @OneToMany, @ManyToOne, @ManyToMany? write some examples. 
In Java Persistence API (JPA), @OneToMany, @ManyToOne, and @ManyToMany are annotations used to define the relationships between entities in a relational database.

```
@Entity
public class Department {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @OneToMany(mappedBy = "department")
    private List<Employee> employees;

    // Getters and setters
}

@Entity
public class Employee {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne
    @JoinColumn(name = "department_id")
    private Department department;

    // Getters and setters
}

```

# 7. What is the cascade = CascadeType.ALL, orphanRemoval = true? and what are the other CascadeType and their features? In which situation we choose which one? 
cascade = CascadeType.ALL
The CascadeType.ALL option specifies that all entity operations should be cascaded to the associated entities. For example, if a Parent entity has a collection of Child entities and CascadeType.ALL is specified, when the Parent entity is persisted or deleted, the same operation will be applied to all associated Child entities as well.

orphanRemoval = true
The orphanRemoval option specifies that when an entity is removed from a collection, it should also be deleted from the database. This option is useful when an entity is dependent on another entity, and deleting one without the other would result in an inconsistent state.

Other CascadeType options:

CascadeType.PERSIST: Specifies that when an entity is persisted, the same operation should be applied to all associated entities.
CascadeType.MERGE: Specifies that when an entity is merged, the same operation should be applied to all associated entities.
CascadeType.REMOVE: Specifies that when an entity is deleted, the same operation should be applied to all associated entities.
CascadeType.DETACH: Specifies that when an entity is detached, the same operation should be applied to all associated entities.
CascadeType.REFRESH: Specifies that when an entity is refreshed, the same operation should be applied to all associated entities.
The choice of CascadeType depends on the relationship between the entities and the desired behavior when performing entity operations. For example, if a Parent entity has a collection of Child entities and CascadeType.ALL is specified, when the Parent entity is deleted, all associated Child entities will also be deleted. On the other hand, if CascadeType.REMOVE is specified, only the associated Child entities will be deleted, but the Parent entity will remain in the database.

# 8. What is the fetch = FetchType.LAZY, fetch = FetchType.EAGER? what is the difference? In which situation you choose which one? 
FetchType.LAZY
FetchType.LAZY specifies that related entities should not be loaded from the database until they are accessed for the first time. This is useful for optimizing performance when dealing with large datasets, as it allows you to load only the entities that are actually needed by the application. In other words, if a relationship is defined with FetchType.LAZY, the related entity will not be loaded from the database until it is accessed via a method call.

FetchType.EAGER
FetchType.EAGER specifies that related entities should be loaded from the database immediately along with the parent entity. This can be useful when you know that you will need the related entity data soon after retrieving the parent entity data, and want to avoid the additional database queries that would be required to load the related entity later.

In general, FetchType.LAZY is the default behavior and is recommended for most scenarios, especially when dealing with large datasets. However, in certain cases, FetchType.EAGER may be appropriate, such as when you know that you will always need the related entity data immediately after loading the parent entity data.

The choice of fetch type depends on the specific requirements of your application. When deciding which fetch type to use, consider factors such as the size of the related entity data, the frequency of access to related entities, and the overall performance of your application.

# 9. What is the rule of JPA naming convention? Shall we implement the method by ourselves? Could you list some examples? 
- Entity classes should be named using singular nouns and start with an uppercase letter. For example, Customer, Product, or Order.

- Properties within an entity class should be named using camelCase, starting with a lowercase letter. For example, firstName, price, or createdAt.

- The name of the entity property should match the name of the corresponding database column. If a property name consists of multiple words, it should be mapped to a column name using underscores. For example, the property firstName would be mapped to the column name first_name.

- Relationships between entities should be named using camelCase and start with a lowercase letter. For example, customer, product, or order.

- Join tables for many-to-many relationships should be named using the concatenation of the two table names in alphabetical order. For example, a join table between the Customer and Product tables would be named customer_product.

# 10. Try to use JPA advanced methods in your class project. In the repository layer, you need to use the naming convention to use the method provided by JPA. 

# 11. (Optional) Check out a new branch(https://github.com/TAIsRich/springboot-red book/tree/hw02_01_jdbcTemplate) from branch 02_post_RUD, replace the dao layer using JdbcTemplate.  
# 12. (Optional) use JDBC to read the data from database. 

# Part2. Spring database 2
# 1. List all of the annotations you learned from class and homework to annotaitons.md 
Please check in annotaitons.md

# 2. type the code, you need to checkout new branch from branch 02_post_RUD, name the new branch with https://github.com/TAIsRich/springboot-redbook/ tree/hw05_01_slides_JPQL. 


# 3. What is JPQL? 
JPQL stands for Java Persistence Query Language. It is a query language used to retrieve data from a database using JPA. JPQL is similar to SQL in syntax, but it operates on entities and their relationships rather than directly on database tables and columns.

# 4. What is @NamedQuery and @NamedQueries? 
In JPA, @NamedQuery and @NamedQueries are annotations used to define named queries that can be used to retrieve data from a database. Named queries are a way to define a query once and use it multiple times throughout the application.

# 5. What is @Query? In which Interface we write the sql or JPQL? 
In JPA, @Query is an annotation used to define a custom query that can be executed using the EntityManager object or a JPA repository. @Query allows developers to write native SQL queries or JPQL queries as strings, which are then executed against the database.

# 6. What is HQL and Criteria Queries? 

In Hibernate, HQL (Hibernate Query Language) and Criteria Queries are two different approaches for querying data from a database.

- HQL is a Hibernate-specific query language that is similar to JPQL. HQL queries are written using Hibernate's object-oriented query language and can include joins, filtering, and sorting of results, among other features. HQL is not standardized across different database systems, so it can only be used with Hibernate.

- Criteria Queries, on the other hand, are a type-safe approach for building queries using the Criteria API. Criteria Queries are written in a platform-independent manner and can be executed on any database system that supports Hibernate.

# 7. What is EnityManager? 
In JPA (Java Persistence API), EntityManager is the main interface used to interact with the persistence context. The EntityManager object provides methods for persisting, retrieving, updating, and deleting JPA entities from a database.

# 8. What is SessionFactory and Session? 
In Hibernate, the SessionFactory and Session interfaces are used to manage the Hibernate session and interact with the database.

SessionFactory is the core interface in Hibernate and is responsible for creating and managing Session instances. The SessionFactory is typically created once for the lifetime of the application and is used to create new Session instances as needed. The SessionFactory is thread-safe and can be shared among multiple threads.

# 9. What is Transaction? how to manage your transaction? 
In JPA and Hibernate, a transaction is a sequence of one or more database operations that are executed as a single unit of work. Transactions ensure that database operations are performed atomically, consistently, and durably, and allow for data integrity and concurrency control.

A transaction in JPA/Hibernate can be managed using the Transaction interface, which provides methods for starting, committing, and rolling back a transaction.

# 10. What is hibernate Caching? 
In Hibernate, caching is a technique used to improve application performance by reducing the number of database queries required to retrieve data. Caching involves storing frequently accessed data in memory, where it can be quickly retrieved without having to query the database.

Hibernate provides two types of caching: first-level cache (also known as the session cache) and second-level cache (also known as the entity cache or query cache).

# 11. What is the difference between first-level cache and second-level cache? 
In Hibernate, there are two types of caching: first-level cache (also known as the session cache) and second-level cache (also known as the entity cache or query cache). The main differences between these two types of cache are:

Scope: First-level cache is associated with a single Hibernate Session, while second-level cache is a shared cache that can be accessed by multiple Hibernate Session instances.

Data: First-level cache stores entity instances that have been retrieved or persisted by a single Hibernate Session, while second-level cache stores entity instances, query results, and other data that can be shared among multiple Hibernate Session instances.

Configuration: First-level cache is enabled by default in Hibernate and requires no configuration, while second-level cache must be explicitly enabled and configured in Hibernate.

Implementation: First-level cache is implemented using a simple HashMap data structure in Hibernate, while second-level cache is typically implemented using an external caching provider, such as Ehcache or Infinispan.

Concurrency: First-level cache is not thread-safe and can only be accessed by a single Hibernate Session instance, while second-level cache is designed to be thread-safe and can be accessed by multiple Hibernate Session instances concurrently.

# 12. How do you understand @Transactional? (不要clone，要自己抄写并测试 transactional，https://github.com/TAIsRich/tutorial-transaction) 


# 13. Write a simple factory design pattern.
```
public interface Shape {
    void draw();
}

public class Circle implements Shape {
    @Override
    public void draw() {
        System.out.println("Drawing a circle");
    }
}

public class Rectangle implements Shape {
    @Override
    public void draw() {
        System.out.println("Drawing a rectangle");
    }
}

public class ShapeFactory {
    public Shape getShape(String shapeType) {
        if (shapeType == null) {
            return null;
        } else if (shapeType.equalsIgnoreCase("CIRCLE")) {
            return new Circle();
        } else if (shapeType.equalsIgnoreCase("RECTANGLE")) {
            return new Rectangle();
        } else {
            return null;
        }
    }
}

public class Main {
    public static void main(String[] args) {
        ShapeFactory shapeFactory = new ShapeFactory();

        Shape circle = shapeFactory.getShape("CIRCLE");
        circle.draw();

        Shape rectangle = shapeFactory.getShape("RECTANGLE");
        rectangle.draw();
    }
}

```