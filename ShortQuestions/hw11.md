# HW 11

## 3. What is the Aspect Oriented Programming?

Aspect-oriented programming (AOP) is a programming technique that supports the separation of **cross-cutting concerns** in order to increase modularity.

AOP is typically used to implement **cross-cutting concerns**, which implies that it defines functionality that is required in multiple places across an application in one place. You can add new functionality before or after a method is executed like transaction management, logging or security which cut across multiple types and objects (often termed crosscutting concerns).

## 4. What are the advantages and disadvantages of Spring AOP?

**Advantages of Spring AOP**

1. It is easy to configure.
2. Spring AOP is implemented in pure Java, so separate compilation unit or separate class loader are not required.
3. It utilizes Spring's IOC container for dependency injection.
4. Can create aspects using `@AspectJ` annotation based or using XML based.
5. It integrates cross-cutting concerns into the classes,.

**Disadvantages of Spring AOP**

1. Debugging the AOP framework-based application code is a little challenge.
2. Only methods with a public visibility will be recommended, not those with a private, protected, or default visibility.
3. Aspects cannot be advised by other aspects. This is because once a class is marked as an aspect (using XML or annotation), Spring prevents it from being auto-proxied.

## 5. What is Aspect in Spring AOP?

An aspect is a cross-cutting module that combines advice and pointcuts. A standard class tagged with the @Aspect annotation can be used to implement an aspect.

Aspects are mostly used to enable cross-cutting concerns like logging, profiling, caching, and transaction management.

## 6. What is Pointcut in Spring AOP?

A pointcut is an expression that chooses one or more join points at which advice is given. Pointcuts can be defined using **expressions or patterns**. It supports a number of expressions that correspond to the join points.

## 7. What is the Join point in Spring AOP?

A join point is a place in the application where an AOP aspect is applied. It could also be a specific advice execution instance. A join point in AOP can be a method execution, exception handling, changing the value of an object variable, and so on.

## 8. What does it mean by Advice and its types in Spring AOP?

The advice is an action which we take before or after the method execution**. In the Spring AOP framework, there are five types of advice: before**, after**, after-returning**, after-throwing**, and around advice**. Advice is taken at a specific join point.

## 10. When to use Spring Batch? 

Consider an environment where users have to do a lot of batch processing. This will be quite different from a typical web application which has to work 24/7. But in classic environments it's not unusual to do the heavy lifting for example during the night when there are no regular users using your system. Batch processing includes typical tasks like reading and writing to files, transforming data, reading from or writing to databases, create reports, import and export data and things like that. Often these steps have to be chained together or you have to create more complex workflows where you have to define which job steps can be run in parallel or have to be run sequentially etc. That's where a framework like Spring Batch can be very handy. Spring Boot Batch provides reusable functions that are essential in processing large volumes of records, including logging/tracing, transaction management, job processing statistics, job restart, skip, and resource management. It also provides more advanced technical services and features that will enable extremely high-volume and high performance batch jobs though optimization and partitioning techniques.Simple as well as complex, high-volume batch jobs can leverage the framework in a highly scalable manner to process significant volumes of information.

## 11. How Spring Batch works?

- **step -** A Step that delegates to a Job to do its work. This is a great tool for managing dependencies between jobs, and also to modularise complex step logic into something that is testable in isolation. The job is executed with parameters that can be extracted from the step execution, hence this step can also be usefully used as the worker in a parallel or partitioned execution.
- **ItemReader -** Strategy interface for providing the data. Implementations are expected to be stateful and will be called multiple times for each batch, with each call to read() returning a different value and finally returning null when all input data is exhausted. Implementations need not be thread-safe and clients of a ItemReader need to be aware that this is the case. A richer interface (e.g. with a look ahead or peek) is not feasible because we need to support transactions in an asynchronous batch.
- **ItemProcessor -** Interface for item transformation. Given an item as input, this interface provides an extension point which allows for the application of business logic in an item oriented processing scenario. It should be noted that while it's possible to return a different type than the one provided, it's not strictly necessary. Furthermore, returning null indicates that the item should not be continued to be processed.
- **ItemStreamWriter -** Basic interface for generic output operations. Class implementing this interface will be responsible for serializing objects as necessary.

## 12. How can we schedule a Spring Batch Job?

[Spring Batch 之 背景框架简介](https://blog.csdn.net/wuzhiwei549/article/details/85392128)

[Spring Batch 之 Job的创建和调用](https://blog.csdn.net/wuzhiwei549/article/details/85394406)

[Spring Batch 之 flow 介绍和使用](https://blog.csdn.net/wuzhiwei549/article/details/85405443)

Spring Batch is a framework that is used for batch processing - processing a large amount of data by splitting it into small chunks. However, it does not have built-in scheduling support. If you want to schedule a batch job, you would need to use a job scheduler like Spring's own scheduling support, Quartz, or the scheduling support in your application server or operating system.

```java
package com.batch.demo.flow.jobFlowDemoOne;
 
import org.springframework.batch.core.Job;
import org.springframework.batch.core.Step;
import org.springframework.batch.core.StepContribution;
import org.springframework.batch.core.configuration.annotation.JobBuilderFactory;
import org.springframework.batch.core.configuration.annotation.StepBuilderFactory;
import org.springframework.batch.core.scope.context.ChunkContext;
import org.springframework.batch.core.step.tasklet.Tasklet;
import org.springframework.batch.repeat.RepeatStatus;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
 
@Configuration
public class JobFlowDemoOne {
 
    @Autowired
    private JobBuilderFactory jobBuilderFactory;
 
    @Autowired
    private StepBuilderFactory stepBuilderFactory;
 
    @Bean
    public Job JobFlowDemo1(){
        return jobBuilderFactory.get("jobFlowDemo1")
                .start(step1())
                .next(step2())
                .next(step3())
                .build();
    }
 
    @Bean
    public Step step1() {
        return stepBuilderFactory.get("step1")
                .tasklet(new Tasklet() {
                    @Override
                    public RepeatStatus execute(StepContribution stepContribution, ChunkContext chunkContext) throws Exception {
                        System.out.println("step 1");
                        return RepeatStatus.FINISHED;
                    }
                }).build();
    }
 
    @Bean
    public Step step2() {
        return stepBuilderFactory.get("step2")
                .tasklet((contribution,context)->{
                    System.out.println("step 2");
                    return RepeatStatus.FINISHED;
                }).build();
    }
 
    @Bean
    public Step step3() {
        return stepBuilderFactory.get("step3")
                .tasklet(new Tasklet() {
                    @Override
                    public RepeatStatus execute(StepContribution stepContribution, ChunkContext chunkContext) throws Exception {
                        System.out.println("step 3");
                        return RepeatStatus.FINISHED;
                    }
                }).build();
    }
    
        @Bean
    public Job JobFlowDemo1(){
        return jobBuilderFactory.get("jobFlowDemo1")
//                .start(step1())
//                .next(step2())
//                .next(step3())
//                .build();
                .start(step1()).on("COMPLETED").to(step2())
                .from(step2()).on("COMPLETED").to(step3())
                .from(step3()).end()
                .build();
    }
}
```

## 13. What is the cron expression?

Cron is a time-based job scheduler in Unix-like operating systems. Users can schedule jobs (commands or scripts) to run periodically at fixed times, dates, or intervals.

A cron expression is a string representing a schedule in the cron syntax. Cron expressions are used in various job schedulers (like the one in the Spring Framework), task schedulers, and the like.

Cron expressions have six or seven fields separated by a white space.

Here's the general format:

```java
<second> <minute> <hour> <day-of-month> <month> <day-of-week> <year> (optional field)

```

Each field can have a specific value or a range of values:

- `*` means any value or always.
- `*/5` in the minute field means every 5 minutes.
- `10,20,30` in the minute field means minute 10, 20, or 30.
- `5-10` in the day-of-month field means from the 5th to the 10th day of the month.
- `MON-WED,SAT` in the day-of-week field means every Monday, Tuesday, Wednesday, and Saturday.

Here are a few examples of cron expressions:

- `0 0 12 * * ?` - run job at 12 PM (noon) every day
- `0 15 10 ? * *` - run job at 10:15 AM every day
- `0 0/5 14 * * ?` - run job every 5 minutes starting at 2 PM and ending at 2:55 PM, every day
- `0 10,44 14 ? 3 WED` - run job at 2:10 PM and at 2:44 PM every Wednesday in the month of March
- `0 15 10 ? * MON-FRI` - run job at 10:15 AM every Monday, Tuesday, Wednesday, Thursday and Friday

## 14. What is the spring task?

Spring Framework provides a Task Execution and Scheduling abstraction with the TaskExecutor and TaskScheduler interfaces, respectively. These abstractions allow you to schedule tasks to run at fixed rate, fixed delay, or cron-based times, without needing to directly interface with native scheduling APIs such as `java.util.Timer` or `java.util.concurrent.Executor`.

1. TaskExecutor: The `TaskExecutor` interface is similar to the `java.util.concurrent.Executor` interface and is used to execute `Runnable` objects. There are various `TaskExecutor` implementations provided by Spring:
   - `SimpleAsyncTaskExecutor`: Doesn't reuse any threads, essentially creates a new thread for every task.
   - `SyncTaskExecutor`: Doesn't use any threads, but rather executes all tasks in the calling thread.
   - `ConcurrentTaskExecutor`: Adapts a `java.util.concurrent.Executor` instance to the `TaskExecutor` interface.
   - `ThreadPoolTaskExecutor`: A `java.util.concurrent.ThreadPoolExecutor` extension that conforms to the `TaskExecutor` interface.
2. TaskScheduler: The `TaskScheduler` interface provides methods to schedule tasks to run after a certain delay, or at a fixed-rate or fixed-delay or at cron-based times.

```java
@Component
public class MyScheduledTask {

    @Scheduled(fixedRate = 1000)
    public void performTask() {
        System.out.println("MyScheduledTask performed at " + new Date());
    }
}

```

## 15. When to use Spring task?

Spring's Task Execution and Scheduling abstraction, including the `TaskExecutor` and `TaskScheduler` interfaces, are particularly useful in the following scenarios:

1. **Asynchronous Processing**: If you have tasks that can be performed in the background, without the user having to wait for the task to complete to continue using your application, you can use `TaskExecutor` to execute these tasks asynchronously. This is beneficial for tasks such as sending emails, processing files, or any heavy computation that can be done in the background.
2. **Scheduled Tasks**: If you have tasks that need to be run at fixed intervals, like running a cleanup script every day at midnight, or generating daily, weekly, or monthly reports, you can use `TaskScheduler` with cron expressions or fixed delay/rate configurations to schedule these tasks.
3. **Parallel Processing**: If you have tasks that can be broken down into smaller tasks and executed in parallel, you can use `TaskExecutor` to improve the performance of your application. This can be particularly useful for CPU-intensive tasks that can be performed concurrently.
4. **Rate Limiting**: If you need to limit the rate at which a certain task is executed, you can use `TaskScheduler` to ensure that the task is executed at a fixed rate.

Remember that while Spring's Task abstractions are simple to use and integrate well with Spring applications, they are not a replacement for a full-fledged task scheduling solution like Quartz, which offers features like task persistence, clustering, and more complex scheduling options. Use Spring's Task abstractions when they meet your requirements, but don't hesitate to use a more advanced solution if needed.

## 16. What is Filter and any filter example?

Filters perform filtering in the `doFilter` method. Every Filter has access to a `FilterConfig` object from which it can obtain its initialization parameters, and a reference to the `ServletContext` which it can use, for example, to load resources needed for filtering tasks.

Filters are deployed in the web.xml file, where you specify which pages or servlets they should be applied to.

```java
import javax.servlet.*;
import javax.servlet.http.HttpServletRequest;
import java.io.IOException;

public class LogFilter implements Filter {

    public void init(FilterConfig config) throws ServletException {
        // Initialization code...
    }

    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
        HttpServletRequest httpRequest = (HttpServletRequest) request;
        System.out.println("HTTP Request: " + httpRequest.getRequestURI());

        // Continue process the HTTP request
        chain.doFilter(request, response);
    }

    public void destroy() {
        // Cleanup code...
    }
}

```

In Spring Boot, filters can be registered in the code without modifying `web.xml`. Here is an example:

```java
@Configuration
public class FilterConfig {

    @Bean
    public FilterRegistrationBean<LogFilter> loggingFilter(){
        FilterRegistrationBean<LogFilter> registrationBean = new FilterRegistrationBean<>();

        registrationBean.setFilter(new LogFilter());
        registrationBean.addUrlPatterns("/*");

        return registrationBean;
    }
}

```

## 17. What is the Interceptor? What we can do with interceptor?


Interceptors are components that are used to intercept HTTP requests and responses in a web application. They can be used to pre-process and post-process requests and responses, giving developers a chance to add common behavior across multiple endpoints.

Here are some common use cases for interceptors:

1. **Logging**: Interceptors can be used to log details of HTTP requests and responses. This can be useful for debugging, auditing, or tracking user actions.
2. **Authentication and Authorization**: Interceptors can check whether a user is authenticated or has the necessary permissions to access a particular resource.
3. **Modifying Requests and Responses**: Interceptors can modify the request or response. For example, they can add, remove, or change HTTP headers.
4. **Performance Monitoring**: Interceptors can be used to track the time taken to process a request and generate a response.
5. **CORS**: Interceptors can add CORS (Cross-Origin Resource Sharing) headers to the response to allow cross-domain requests.

In Spring, you can create an interceptor by implementing the `HandlerInterceptor` interface or by extending the `HandlerInterceptorAdapter` class. An interceptor has three methods that you can override:

- `preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)`: This method is called before the actual handler is executed. You can use this method to pre-process the request. If this method returns `false`, the handler execution chain is stopped, and the handler is not executed.
- `postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)`: This method is called after the handler is executed. You can use this method to post-process the request, such as adding additional attributes to the model.
- `afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)`: This method is called after the request is completely processed, and the view is rendered. You can use this method to perform cleanup tasks.

```java
import org.springframework.web.servlet.handler.HandlerInterceptorAdapter;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class LoggingInterceptor extends HandlerInterceptorAdapter {

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        System.out.println("Before handler execution. Handling " + request.getRequestURI());
        return true;
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        System.out.println("After handler execution. View name: " + (modelAndView != null ? modelAndView.getViewName() : "null"));
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        System.out.println("After complete execution. Response status: " + response.getStatus());
    }
}
```

## 18. In Interceptor, What is preHandle? What is postHandle?

- `preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)`: This method is called before the actual handler is executed. You can use this method to pre-process the request. If this method returns `false`, the handler execution chain is stopped, and the handler is not executed.
- `postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)`: This method is called after the handler is executed. You can use this method to post-process the request, such as adding additional attributes to the model.