
## 1. List all of the annotations you learned from class and homework to annotaitons.md

Check ShortQuestions/annotations.md

## 2. Briefly reading: https://www.techgeeknext.com/spring-boot/spring-aop-interview-questions

Done

## 3. What is the Aspect Oriented Programming?

Aspect-oriented programming (AOP) is a programming technique that supports the separation of cross-cutting concerns in order to increase modularity.
AOP is typically used to implement cross-cutting concerns, which implies that it defines functionality that is required in multiple places across an application in one place. You can add new functionality before or after a method is executed like transaction management, logging or security which cut across multiple types and objects (often termed crosscutting concerns).

## 4. What are the advantages and disadvantages of Spring AOP?


**Advantages of Spring AOP:**

* **Modularity:** AOP allows you to modularize cross-cutting concerns, such as logging, security, and transaction management, into reusable aspects. This improves code organization and maintainability.

* **Code Reusability:** Aspects can be applied to multiple classes and methods, reducing code duplication and promoting reusability.

* **Loose Coupling:** AOP enables loose coupling between aspects and the core business logic. The core logic remains unaware of the aspects, making it easier to modify or add new aspects without affecting the core functionality.

* **Improved Readability:** By separating cross-cutting concerns, the core code becomes more focused and easier to understand, as it only contains the essential business logic.

**Disadvantages of Spring AOP:**

* **Limited to Method-Level Join Points:** Spring AOP is primarily focused on method-level join points, meaning it may not be suitable for handling cross-cutting concerns at other granularities, such as field access or constructor invocations.

* **Runtime Performance Overhead:** The application of aspects at runtime can introduce a performance overhead, especially for complex and heavily used systems. However, the impact is generally manageable for most applications.

* **Limited Pointcut Expressions:** Spring AOP provides a limited set of pointcut expressions compared to more advanced AOP frameworks. This may restrict the flexibility of defining pointcuts for complex scenarios.

* **Proxy-Based Approach:** Spring AOP uses proxy-based AOP, which means it creates proxy objects to intercept method invocations. This approach imposes certain limitations, such as limitations on self-invocation and restrictions on final methods and classes.

## 5. What is Aspect in Spring AOP?

An aspect is a cross-cutting module that combines advice and pointcuts. A standard class tagged with the @Aspect annotation can be used to implement an aspect.

Aspects are mostly used to enable cross-cutting concerns like logging, profiling, caching, and transaction management.

## 6. What is Pointcut in Spring AOP?

A pointcut is an expression that chooses one or more join points at which advice is given. Pointcuts can be defined using expressions or patterns. It supports a number of expressions that correspond to the join points.

## 7. What is the Join point in Spring AOP?

A join point is a place in the application where an AOP aspect is applied. It could also be a specific advice execution instance. A join point in AOP can be a method execution, exception handling, changing the value of an object variable, and so on.

## 8. What does it mean by Advice and its types in Spring AOP?

The advice is an action which we take before or after the method execution. In the Spring AOP framework, there are five types of advice: before, after, after-returning, after-throwing, and around advice. Advice is taken at a specific join point

## 9. Reading: https://www.javainuse.com/spring/sprbatch_interview

Done

## 10. When to use Spring Batch?

Spring Batch is commonly used in scenarios where you need to process large volumes of data in a batch or bulk manner. It provides a framework for building robust and scalable batch processing applications.

## 11. How Spring Batch works?

* **step** - A Step that delegates to a Job to do its work. This is a great tool for managing dependencies between jobs, and also to modularise complex step logic into something that is testable in isolation. The job is executed with parameters that can be extracted from the step execution, hence this step can also be usefully used as the worker in a parallel or partitioned execution.
* **ItemReader** - Strategy interface for providing the data. Implementations are expected to be stateful and will be called multiple times for each batch, with each call to read() returning a different value and finally returning null when all input data is exhausted. Implementations need not be thread-safe and clients of a ItemReader need to be aware that this is the case. A richer interface (e.g. with a look ahead or peek) is not feasible because we need to support transactions in an asynchronous batch.
* **ItemProcessor** - Interface for item transformation. Given an item as input, this interface provides an extension point which allows for the application of business logic in an item oriented processing scenario. It should be noted that while it's possible to return a different type than the one provided, it's not strictly necessary. Furthermore, returning null indicates that the item should not be continued to be processed.
* **ItemStreamWriter** - Basic interface for generic output operations. Class implementing this interface will be responsible for serializing objects as necessary. Generally, it is responsibility of implementing class to decide which technology to use for mapping and how it should be configured. The write method is responsible for making sure that any internal buffers are flushed. If a transaction is active it will also usually be necessary to discard the output on a subsequent rollback. The resource to which the writer is sending data should normally be able to handle this itself.

## 12. How can we schedule a Spring Batch Job?

* **Using Spring's TaskScheduler:** By configuring the TaskScheduler, you can schedule the execution of jobs at specified intervals or fixed time points. You can use annotations like @Scheduled or programmatic scheduling to define the timing for job execution.

* **Using Quartz scheduler:** Integrating with the Quartz scheduler provides more flexibility in managing job scheduling. You can configure Cron expressions or simple triggers to schedule job execution.

* **Using external scheduling tools:** Configure the Spring Batch job as a standalone executable and use external scheduling tools like cron jobs or Windows Task Scheduler to run the job periodically.

## 13. What is the cron expression?

A cron expression is a string representation of a schedule that specifies the timing details for recurring tasks. It is commonly used in scheduling systems, including Spring Batch, to define when a job or task should be executed.

A cron expression consists of six fields that represent different components of time: seconds, minutes, hours, day of the month, month, and day of the week. Each field can contain a specific value, a range of values, or special characters to represent intervals or wildcard values.

**structure**

```java
┌───────────── second (0 - 59)
│ ┌───────────── minute (0 - 59)
│ │ ┌───────────── hour (0 - 23)
│ │ │ ┌───────────── day of the month (1 - 31)
│ │ │ │ ┌───────────── month (1 - 12)
│ │ │ │ │ ┌───────────── day of the week (0 - 7) (Sunday to Saturday, 0 or 7 represents Sunday)
│ │ │ │ │ │
│ │ │ │ │ │
* * * * * *
```
**examples:**

* **0 * * * * *:** Executes every minute at the beginning of the minute.
* **0 0 12 * * ?:** Executes once a day at 12:00 PM.
* **0 0 8-18/2 ? * MON-FRI:** Executes every two hours from 8 AM to 6 PM, Monday to Friday.

## 14. What is the spring task?

In the Spring framework, Spring Task is a mechanism for scheduling tasks. It is based on the ScheduledExecutorService interface in Java and provides a simple and flexible way to execute tasks at specified intervals.

Spring Task allows you to define methods with scheduled triggers that will be automatically executed at the specified time intervals. It offers several scheduling options, including fixed rate, fixed delay, and cron expressions.

You can define Spring Task using annotations or XML configuration. With annotations, you can add the @Scheduled annotation to methods and specify the scheduling rules for the tasks. With XML configuration, you can define a <task:scheduled> element in an XML file and configure the scheduling rules within it.

## 15. When to use Spring task?

Spring Task, also known as Spring Scheduling, is used when you need to schedule and execute tasks at specific times or intervals in your Spring application. You can use Spring Task in various scenarios, including:

* **Periodic tasks:** When you have tasks that need to run at fixed intervals, such as generating reports, sending notifications, or updating cache.

* **Background tasks:** When you have long-running tasks that need to be executed asynchronously in the background, without blocking the main application thread.

* **Cron jobs:** When you need to schedule tasks based on complex time-based patterns using cron expressions, such as running a task every day at a specific time or on specific days of the week.

* **Task scheduling in distributed environments:** When you have a distributed system and need a centralized mechanism to schedule and coordinate tasks across multiple nodes or instances.

## 16. What is Filter and any filter example?

In the context of web applications, a filter is a component that intercepts and processes incoming requests and outgoing responses. It sits between the web server and the servlet responsible for handling the request, allowing for pre-processing and post-processing of the request and response.

A filter can perform various tasks such as authentication, authorization, logging, request/response modification, error handling, and more. It provides a way to add additional functionality to the standard request/response processing flow without modifying the underlying servlet or application code.

```java
import javax.servlet.*;
import javax.servlet.http.HttpServletRequest;
import java.io.IOException;

public class LoggingFilter implements Filter {

    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
        // 如果需要，进行初始化操作
    }

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
            throws IOException, ServletException {
        HttpServletRequest httpRequest = (HttpServletRequest) request;
        String requestURI = httpRequest.getRequestURI();
        String method = httpRequest.getMethod();
        System.out.println("接收到请求：" + method + " " + requestURI);

        // 将请求和响应传递给过滤器链中的下一个过滤器或Servlet
        chain.doFilter(request, response);
    }

    @Override
    public void destroy() {
        // 如果需要，进行清理操作
    }
}
```
## 17. What is the Interceptor? What we can do with interceptor?
In the Spring framework, an interceptor is a component used for handling web requests. It is similar to a filter but provides more fine-grained control and richer functionality.

Interceptors allow you to intervene at different stages of request processing, enabling you to execute custom logic before and after the handler execution. They are commonly used to accomplish the following tasks:

Authentication and authorization: Interceptors can be used to validate user identity and check their permissions, ensuring that only authorized users can access protected resources.

* **Logging:** Interceptors can log detailed information about requests, such as the request URL, parameters, processing time, etc., for monitoring and troubleshooting purposes.

* **Data conversion and formatting:** Interceptors can perform data conversion and formatting on requests or responses, such as formatting dates to a specific format, decrypting request data, etc., before or after request processing.

* **Caching:** Interceptors can check for the existence of a cached copy and return cached data if necessary, improving performance.

* **Exception handling:** Interceptors can capture and handle exceptions that occur in the handler, performing appropriate actions or converting them as needed.

Interceptors are defined and implemented using the HandlerInterceptor interface provided by Spring. You can write custom interceptors and register them in the configuration to execute the corresponding actions during request processing.

## 18. In Interceptor, What is preHandle? What is postHandle?
In an interceptor, preHandle and postHandle are two methods.

The preHandle method is executed before the actual handler (controller method) is invoked. It is used for pre-processing tasks or validations.

The postHandle method is executed after the handler method has completed execution but before the view is rendered. It is used for post-processing tasks or modifying the model and view.

## 19. What is Swagger?

Swagger is an open-source framework that helps developers design, build, document, and consume RESTful APIs. It provides a set of tools and specifications to describe the structure, endpoints, input/output formats, and authentication mechanisms of an API.

The main components of Swagger are:

* **Swagger Specification (OpenAPI Specification):** It is a machine-readable JSON or YAML file that describes the API endpoints, request/response formats, parameters, and other details.

* **Swagger UI:** It is a web-based interface that automatically generates interactive API documentation from the Swagger specification. It allows developers to visualize and explore the API endpoints, make requests, and view responses.

* **Swagger Codegen:** It is a tool that generates client SDKs, server stubs, and API documentation based on the Swagger specification. It supports multiple programming languages and frameworks.

By using Swagger, developers can easily create, test, and document APIs, improving collaboration between frontend and backend teams and facilitating API consumption by third-party developers. It promotes API standardization, simplifies API maintenance, and enhances the overall developer experience.
