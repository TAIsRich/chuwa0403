# HW11

*Claudia Feng*

1. List all of the annotations you learned from class and homework to annotaitons.md

   

2. Briefly reading: https://www.techgeeknext.com/spring-boot/spring-aop-intervie w-questions

   

3. What is the Aspect Oriented Programming?

   Aspect-Oriented Programming (AOP) is a programming paradigm that aims to increase modularity by allowing the separation of cross-cutting concerns. It does so by adding additional behavior to existing code (an advice) without modifying the code itself, instead separately specifying which code is modified via a "pointcut" specification, such as "log all function calls when the function's name begins with 'set'". This allows behaviors that are not central to the business logic (such as logging, security, or caching) to be added to a program without cluttering the code that is central to the functionality.

   

4. What are the advantages and disadvantages of Spring AOP?

   **Advantages of Spring AOP:**

   1. **Modularity**: Spring AOP helps to improve the modularity of applications by separating cross-cutting concerns from the main business logic. Aspects can be developed and maintained separately from the core application code.
   2. **Reusability**: The aspects created in Spring AOP can be used across multiple classes and methods, enhancing the reusability of code.
   3. **Readability and Maintainability**: Since cross-cutting concerns are modularized, the main business logic becomes easier to read and maintain.
   4. **Easier Debugging and Testing**: By separating concerns, the code can be more easily tested and debugged as individual aspects can be tested in isolation.
   5. **Integration**: Spring AOP is tightly integrated with Spring IOC (Inversion of Control), which makes it easy to manage AOP objects as Spring Beans.
   6. **Dynamic Proxying**: Spring AOP uses runtime weaving which allows aspects to be applied dynamically at runtime.

   **Disadvantages of Spring AOP:**

   1. **Performance**: As Spring AOP is implemented using runtime proxies, it can add overhead to the application and degrade performance.

   2. **Complexity**: AOP can add another level of complexity to the application. Developers need to be familiar with the concepts of AOP, which might have a steep learning curve for some.

   3. **Limited Support**: Spring AOP does not provide as many pointcut expressions as, for example, AspectJ. This means it is not suitable for every use case.

   4. **Visibility**: Since the aspects are applied during the runtime, it can be more difficult to trace through the code and see what is happening. This can make debugging more challenging.

   5. **Method Level Only**: Spring AOP only supports method execution join points, limiting its use to methods only.

      

5. What is Aspect in Spring AOP?

   This is the module or class that encapsulates the concern that should be modularized. It's a unit of modularity in AOP.

   

6. What is Pointcut in Spring AOP?

   This is the set of join points where an advice should be executed. It is a program element that picks out certain join points in a program.

   

7. What is the Join point in Spring AOP?

   This is the specific point in the execution of the program, such as method execution, exception handling, or object instantiation and destruction.

   

8. What does it mean by Advice and its types in Spring AOP?

   **Advice**: The code to be executed at a particular join point. This is the implementation of the concern that should be modularized.

   Spring AOP supports five types of advice:

   1. **Before advice**: These are advices that execute before the join point method executes. If you want to do some task before a method execution, you can use before advice. For example, for logging or authentication purposes.

   2. **After returning advice**: These are advices that execute after the join point method completes executing normally. This is used when you need to execute some code after a method executes, assuming the method completes successfully. For example, you might use this for logging the successful execution of a method.

   3. **After throwing advice**: These are advices that execute if a method exits by throwing an exception. This is used when you want to log an error or do some other action when a method throws an exception.

   4. **After (finally) advice**: These are advices that execute regardless of the means by which a join point exits (normal or exceptional return). This means the advice will run whether the method completes successfully or throws an exception. This is used when you want to ensure some code runs no matter what happens with the method execution, such as releasing a resource in a finally block.

   5. **Around advice**: These are advices that execute both before and after the join point method. This is the most powerful type of advice, and it's used when you need to execute code both before and after a method executes. For example, you might use this for starting and stopping a timer to measure method execution time, or to open and close a database transaction. An around advice can also choose to not proceed to the join point (i.e., to skip the call to the method), which can be useful in some scenarios like for short-circuiting redundant operations.

      

9. Reading: https://www.javainuse.com/spring/sprbatch_interview

   

10. When to use Spring Batch?

    Spring Batch is a powerful module in the Spring Framework that simplifies the development of batch processing applications. It provides robust and scalable solutions for handling large volumes of data and managing batch processing tasks.

    

11. How Spring Batch works?

    1. **Job**: In Spring Batch, a job is a sequence of steps that encapsulates the entire batch process. A job can have one or more steps.
    2. **Step**: A step is a domain object that encapsulates an independent, sequential phase of a batch job. It has two main components: a `Reader` and a `Writer`.
    3. **Reader**: This is responsible for reading input data for a batch job. The input can come from various sources like a database, an XML file, a CSV file, etc. Spring Batch provides different item readers.
    4. **Processor**: Once data is read, it can be passed to a `Processor`. This is an optional part of a step and is used to transform data between the `Reader` and the `Writer`.
    5. **Writer**: This is responsible for writing the processed data to a particular destination, which could be a database, an XML file, a CSV file, etc. Spring Batch provides different item writers.
    6. **JobLauncher**: The `JobLauncher` is the entry point into the Spring Batch system. When a job is launched, the `JobLauncher` is responsible for starting the job and returning the results when the job completes.
    7. **JobRepository**: This is used by the Spring Batch framework to store metadata about configured jobs and job executions. It typically uses a relational database to persist this metadata, which helps in tracking job statuses, failures, restarts, etc.

    

12. How can we schedule a Spring Batch Job?

    **1. Spring's Task Scheduler**

    Spring Framework provides task scheduling capabilities using the `TaskScheduler` interface. 

    **2. Quartz Scheduler**

    Quartz is a full-featured, open-source job scheduling service that can be integrated within virtually any Java application. Quartz can be used to create simple or complex schedules for executing multiple jobs.

    

13. What is the cron expression?

    A cron expression is a string representing a schedule in the Unix cron syntax, which is used to configure instances of CronTrigger in Unix-like operating systems. Cron is a job scheduling subsystem used in these systems.

    A cron expression is a string of fields separated by spaces. Each field represents a particular unit of time.

    1. **Seconds**: This field can have values from 0-59.

    2. **Minutes**: This field can have values from 0-59.

    3. **Hours**: This field can have values from 0-23.

    4. **Day of Month**: This field can have values from 1-31.

    5. **Month**: This field can have values from 1-12 or JAN-DEC.

    6. **Day of Week**: This field can have values from 0-7 or SUN-SAT (both 0 and 7 represent Sunday).

    7. **Year (optional)**: This field can be left blank or have values from 1970-2099.

       

14. What is the spring task?

    Spring Task is a part of the Spring Framework that provides abstractions for asynchronous execution and scheduling of tasks. It provides a simplified way to create and run tasks asynchronously in a Spring application without having to deal directly with lower-level concurrency features in Java like threads.

    Spring Task provides two main types of functionality:

    1. **Task Execution**: Spring Task provides abstractions for running tasks asynchronously, such as the `TaskExecutor` interface. This provides a simple way to run tasks in the background, freeing up the main application thread to continue processing other requests. This can be used whenever you have a task that can be run asynchronously to improve the performance or responsiveness of your application.
    2. **Task Scheduling**: Spring Task also provides abstractions for scheduling tasks to be run at fixed intervals, after a fixed delay, or according to a cron expression. This can be used whenever you have tasks that need to be run on a regular schedule.

    

15. When to use Spring task?

    - **Background tasks**: If you have tasks that can run in the background without blocking the main application thread, you can use Spring Task's TaskExecutor to run these tasks asynchronously.
    - **Scheduled tasks**: If you have tasks that need to be run on a regular schedule, like nightly database cleanup tasks or periodically fetching data from an API, you can use Spring Task's scheduling features to easily set up these tasks.
    - **Complex scheduling**: If you need more complex scheduling based on cron expressions, you can use the `@Scheduled` annotation with a cron attribute to schedule tasks.

    

16. What is Filter and any filter example?

    `Filter` is an object that performs filtering tasks on either the request to a resource (a servlet or static content), or on the response from a resource, or both.

    

17. What is the Interceptor? What we can do with interceptor?

    Interceptors are components that allow you to intercept web requests and perform some operation before they reach the controller, or modify the responses returning from the controller.

    You can use Spring MVC interceptors for various tasks such as:

    - Logging
    - Authentication and Authorization
    - Locale change
    - Data formatting
    - Setting common model data
    - And many more

    

18. In Interceptor, What is preHandle? What is postHandle?

    1. `preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)`: This method is called before the actual handler (controller method) is executed. This is mainly used to pre-process a request, such as setting attributes, logging, or authentication. You can decide to not further propagate the request (and thus not call the controller method) by returning `false`.
    2. `postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)`: This method is called after the handler is executed and the ModelAndView is prepared. It can be used to add or modify model data that will be used in the view or to modify the view itself.

    

19. What is Swagger?

​	Swagger, also known as OpenAPI, is a set of tools for building APIs that adhere to the OpenAPI 	Specification (OAS). It provides a framework to design, build, document, and consume RESTful web services. The primary goal of Swagger is to enable client and documentation systems to update at the same pace as the server, allowing the API to be described in a common language that everyone can understand.