# HW12
## 1.  List all the new learned annotations to your annotations.md
## 2.  what is selenium(YouTube)?
It enables developers to write scripts or code that can automate various web browser activities, such as clicking buttons, filling out forms, navigating through pages, and extracting data. 

It's commonly used for web application testing and web scraping tasks.   
It allows developers to simulate user interactions with a web application, verify the behavior and functionality of the application, and perform automated regression testing to ensure the stability of the application over time.     
With Selenium, developers can write test scripts that mimic real user interactions, perform actions across different browsers and platforms, and assert the expected outcomes of those interactions. It provides features like element locating, waiting for page loads, handling alerts, and capturing screenshots, allowing developers to create comprehensive and reliable test suites.
## 3.  what is cucumber(YouTube)?
Cucumber is an open-source testing framework that supports behavior-driven development (BDD). 
It allows developers, testers, and business stakeholders to collaborate and define test cases in a human-readable format that can be easily understood by both technical and non-technical team members.  

Cucumber enables the creation of executable specifications using a simple, plain-text format called `Gherkin`. 
`Gherkin` utilizes a set of keywords to describe application behavior and scenarios. 
These scenarios can then be automated and executed as test cases.

## 4.  what is JMeter(YouTube)?
It is an open-source performance testing tool designed for load testing and stress testing of software applications. 
It allows developers and testers to simulate real-world scenarios and measure the performance and behavior of applications under different loads.  

JMeter enables the creation of test plans that simulate multiple users, requests, and network conditions to assess the performance of an application. 
It can generate a large number of concurrent requests to stress test the application and identify performance bottlenecks.

## 5.  what is unit-test?
Unit test is a testing technique where individual components or units of a software system are tested in isolation to ensure their correctness and functionality. 
It involves writing and executing automated tests that target specific units of code, such as functions, methods, or classes, to verify their behavior and validate their output.

Unit tests focus on testing small, independent parts of the software to ensure that they work as expected. 
These tests are typically written by developers during the development process to catch bugs at an ealier stage.

## 6.  What is the lifecycle of Junit?
`@BeforeAll`, `@BeforeEach`, `@Test`, `@AfterEach`, `@AfterAll`.

## 7. Is @BeforeAll method should be Class level(static)?
Yes, it should be declared as a class-level method with the `static` modifier.

The `@BeforeAll` annotation is used to indicate a method that should be executed once before any of the test methods in the test class. 
It is typically used for performing one-time setup tasks or initializing resources that are shared among all test methods.

Since the `@BeforeAll` method is executed before any test methods are run, it needs to be declared as static to ensure it can be called without an instance of the test class. 
This allows the method to be executed at the class level, before any objects of the class are created.

## 8.  What is Mockito? and what is its limitations?
Mockito is a popular open-source Java testing framework that provides support for creating and using mock objects in unit tests.    
We use Mockito for simulating dependencies. So the target can be tested without any influence of the dependencies’ failure.  
Limitations:  
- Limited Support for Final and Static Methods: Mockito **cannot mock final classes and static methods** out of the box. 
However, there are workarounds available, such as using third-party extensions like PowerMock or refactoring code to make it more testable.
- Overuse of Mocking: Mockito should be used judiciously and not overused in unit tests. 
Mocking too many dependencies or mocking extensively within a single test **can lead to overly complex and less readable tests**.
- Potential False Confidence: Mocking dependencies with Mockito can provide a false sense of security if not used appropriately. 
It is important to ensure that the mocked behavior accurately reflects the real behavior of the dependencies.
- 
## 9.  What is @Mock and what is @InjectMocks?
`@Mock` : create mocks (create and inject mocked instances, we don’t create real objects    

`@InjectMocks`: creates actual objects and injects mocked dependencies into it. The `@InjectMocks` annotation is used to automatically inject the mock objects marked with `@Mock` into the target class being tested. 
It enables the creation of an instance of the target class with the mocked dependencies automatically injected.
```aidl
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.junit.jupiter.api.Test;

public class MyTest {

    @Mock
    private MyDependency myDependency;

    @InjectMocks
    private MyClass myClass;

    @Test
    public void testMethod() {
        // Test code using the injected mock dependencies
    }
}
```
The `@InjectMocks` annotation is used to create an instance of the `MyClass` class with the `myDependency` mock object automatically injected into it. 
This allows you to test the behavior of `MyClass` with the mock dependency.

## 10. What is the stubbing?
Stubbing is a concept in software testing and mocking frameworks. 
It means the process of defining predetermined behavior for mock objects or stubs. 
It involves specifying the return values or behavior of methods on the mock objects when they are called during testing.

Stubbing allows developers to simulate the behavior of certain parts of the system under test in order to isolate and focus on testing specific components or interactions. 
By stubbing methods, developers can define the expected responses or behaviors of the mock objects, allowing them to control the test scenario and verify how the system being tested behaves under those conditions.
```aidl
public class MyServiceTest {

    @Test
    public void testGetData() {
        // 创建一个模拟对象
        MyExternalApi mockApi = Mockito.mock(MyExternalApi.class);

        // 定义模拟对象的行为
        Mockito.when(mockApi.getData()).thenReturn("Mocked data");

        // 使用模拟对象进行测试
        MyService myService = new MyService(mockApi);
        String result = myService.getData();

        // 断言结果是否符合预期
        assertEquals("Mocked data", result);
    }
}
```
## 11. what is Mockito ArgumentMatchers
Mockito ArgumentMatchers is a class provided by the Mockito framework that offers a set of static methods to define argument matchers in Mockito-based tests. 
Argument matchers are used to specify the expected arguments during the verification or stubbing of method invocations on mock objects.

With Mockito ArgumentMatchers, we can define flexible argument matching criteria to handle different scenarios in your tests. 

Examples:
- `any()`: Matches any value of the given type.
- `eq(value)`: Matches the exact value of the argument.
- `anyInt()`, `anyString()`, `anyObject()`: Matches any value of the specified type.
- `isNull()`, `notNull()`: Matches null or non-null values, respectively.
- `argThat(matcher)`: Matches arguments based on a custom matcher implementation.
```aidl
import static org.mockito.ArgumentMatchers.*;

// Creating a mock object
List<String> mockList = Mockito.mock(List.class);

// Stubbing the method with argument matching
Mockito.when(mockList.get(anyInt())).thenReturn("Mocked value");

// Verifying the method invocation with argument matching
Mockito.verify(mockList).add(argThat(s -> s.length() > 5));
```

## 12. what is Hamcrest Matchers
It is a library that provides a set of matchers for performing flexible and expressive **assertions** in testing frameworks. 
It is often used with testing frameworks like JUnit or Mockito.

With Hamcrest Matchers, we can write assertions in a more natural language style, 
making it easier to understand the expected behavior of the code being tested. 
Instead of using the default assertion methods provided by the testing framework, 
Hamcrest Matchers provide a wide range of matchers that can be used to specify various conditions and expectations on the tested values.  

Examples:
- `equalTo(value)`: Matches the value using the equals() method.
- `is(instance)`: Matches the exact instance of an object.
- `containsString(substring)`: Matches if the string contains the specified substring.
- `greaterThan(value)`, `lessThan(value)`: Matches if the value is greater than or less than the specified value.
- `hasItem(value)`: Matches if the iterable or collection contains the specified value.  

Example of using Hamcrest Matchers with JUnit:
```aidl
import static org.hamcrest.Matchers.*;

import org.junit.Test;

public class MyTest {

    @Test
    public void testSomething() {
        String value = "Hello, World!";
        
        assertThat(value, equalTo("Hello, World!"));
        assertThat(value, containsString("Hello"));
        assertThat(value.length(), greaterThan(5));
    }
}
```

## 13. do you know @spy? what is difference between @spy and @Mock?
`@Spy`: mockito creates a real instance of the class and tracks every interaction with it. It maintains the state changes to it  
`@Mock`: This is not a real object and does not maintain the state changes to it

## 14. briefly reading this articles
a. https://www.javatpoint.com/examples-of-mockito-and-junit-in-eclipse-ide  
b. https://www.javatpoint.com/junit-tutorial  
c.  https://www.javatpoint.com/testng-tutorial  
d.  https://www.javatpoint.com/jmeter-tutorial  

## 15. Add unit test for CommentServiceImpl, the coverage should be 100%.
See `Coding/hw12/springboot-redbook`
