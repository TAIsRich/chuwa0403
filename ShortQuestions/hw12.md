### 1.  List all of the new learned annotations to your annotations.md

### 2.  what is selenium(YouTube)?
Selenium is an open source testing framework used for automating web application testing. It provides a set of tools and libraries that enable developers to write automated test and perform browser automation tests.

Key features of Selenium:

1. Web Driver: An interface for interacting with web browsers. It allows users to simulate user actions like clicking buttons, filling out forms, navigating pages and extracting data from web browsers.

2. Cross-Browser Support: Selenium supports a wide range of web browsers, including Chrome, Firefox, Safari, Internet Explorer, and Edge. It allows developers to automate tests on different browsers without making significant changes to the test scripts.

3. Grid: It is a distributed testing framework that allows tests to be run on multiple machines and browsers in parallel. Selenium Grid is useful for running tests across different operating systems, browsers, and versions simultaneously, improving test efficiency and coverage.

### 3.  what is cucumber(YouTube)?
Cucumber is an open source framework that suport behavior-driven development (BDD). It provides a framework for creating and executing automated tests in a human-readable format. Cucumber enables the collaboration between developers, testers, and other business stakeholders to create the executable specifications written in plain text format called Gherkin.

Gherkin is a simple, domain-specific language that describes the behavior of an application in a structured format. Gherkin uses a set of keywords (Given, When, Then, And, But) to define scenarios and steps.

Feature Files: Feature files are text files written in Gherkin syntax that describe the behavior of an application feature or user story. Feature files contain scenarios, which are individual test cases with step definitions.

Step Definitions: Step definitions are code implementations that bind the steps in feature files to the actual code that performs the corresponding actions. Step definitions are written in programming languages such as Java, Ruby, or JavaScript.

Test Execution: Cucumber executes feature files by matching the steps in the files with their corresponding step definitions. It runs the tests and generates detailed reports indicating the success or failure of each scenario.

Integrations: Cucumber integrates with various testing frameworks, such as JUnit or TestNG, for running tests and generating reports. It also integrates with other tools like Selenium WebDriver for browser automation.

### 4.  what is JMeter(youtube)?
It is mainly used for stress testing, load testing and performance measurement of web applications. JMeter is written in Java and can be used to simulate heavy user loads and analyze the performance and behavior of an application under various scenarios.
Key features of JMeter:
Test Plan Creation: JMeter uses a hierarchical structure called a "Test Plan" to organize and configure test scenarios. Test plans can be created using the JMeter GUI or by writing XML files manually. Test plans define the sequence of requests, parameters, assertions, and timers for executing test scenarios.

Load Testing: JMeter allows you to simulate multiple concurrent users and generate heavy loads on web applications or APIs to test their performance and scalability. It can simulate various user actions like sending HTTP requests, submitting forms, uploading files, and measuring response times.

Protocols and Technologies: JMeter supports various protocols and technologies, including HTTP, HTTPS, FTP, SOAP, REST, JDBC, JMS, and more. It can handle different types of requests and interactions with web servers, databases, messaging queues, and other systems.

Reporting and Analysis: JMeter provides various reporting and analysis features to evaluate the test results. It generates comprehensive test reports, including response times, throughput, error rates, and other performance metrics. These reports help identify performance bottlenecks, server-side issues, and potential areas for optimization.

Samplers: JMeter supports various samplers that can simulate different types of requests, such as HTTP requests, FTP requests, JDBC database queries, SOAP requests, and more. These samplers allow you to mimic real user interactions with the system under test.

Assertions: JMeter provides assertions to validate the responses received from the target system. You can define assertions to check response codes, response data, or specific patterns within the response.

Listeners: JMeter offers a range of listeners to collect and analyze test results. These listeners generate graphical and tabular reports, including response times, error rates, throughput, and other performance metrics.

Distributed Testing: JMeter supports distributed testing where multiple JMeter instances can be set up on different machines to distribute the load and simulate a larger number of concurrent users. This helps in assessing the performance of the system under realistic conditions.

### 5.  what is unit-test?
A unit test is a type of software testing that focuses on verifying the correctness and functionality of individual units or components of a software system. The purpose of unit testing is to isolate and test the smallest testable parts, typically individual functions or methods, in order to ensure that each unit performs as expected. Unit tests are typically written by developers and are executed during the development process to catch and fix bugs early. They are usually automated, meaning they are written as code and executed using testing frameworks or tools.

Key characteristics and benefits of unit test:

Isolation: Unit tests are designed to test a specific unit in isolation from the rest of the system. Dependencies of the unit under test are often replaced or mocked to ensure that the focus is solely on the behavior of that unit.
Atomicity: Unit tests are small and focused on a specific behavior of a unit. They should be independent of each other, allowing them to be executed individually or as a group.
Fast Execution: Unit tests are typically fast to execute, allowing developers to run them frequently and get quick feedback on the correctness of their code.
Regression Testing: Unit tests provide a safety net by catching bugs and regressions as changes are made to the codebase. Running unit tests after making changes helps ensure that existing functionality has not been inadvertently broken.
Documentation: Unit tests serve as executable documentation, providing examples and illustrating how a particular unit should be used and behave.
Refactoring Support: Unit tests provide confidence when refactoring code by ensuring that the desired functionality is maintained even after making changes.

### 6.  What is the lifecircle of Junit?
The lifecycle of JUnit refers to the sequence of events and phases that occur when executing JUnit tests. The following are the typical stages of the JUnit test lifecycle:

Test Class Initialization: JUnit creates an instance of the test class. It scans the class for test methods annotated with @Test and other relevant annotations.
1. Setup: JUnit invokes the method annotated with @BeforeClass once before any test method in the class. This method is used for setting up any shared resources or expensive operations needed for the entire test class.
2. Test Execution: JUnit executes each test method annotated with @Test individually. It captures the test results, including assertions and any thrown exceptions.
3. Test Teardown: JUnit invokes the method annotated with @After after each test method. This method is used for cleaning up resources or performing any necessary post-test actions.
4. Test Class Teardown: JUnit invokes the method annotated with @AfterClass once after all test methods in the class have been executed. This method is used for cleaning up shared resources or performing any final actions.

The relative annotations:
@BeforeAll: The annotated method will be run once before all the tests in the test class. It's analogous to @BeforeClass in JUnit 4.
@BeforeEach: The annotated method will be run before each test method. It's analogous to @Before in JUnit 4.
@Test: The annotated method is a test method. This is similar to the @Test annotation in JUnit 4.
@AfterEach: The annotated method will be run after each test method. It's analogous to @After in JUnit 4.
@AfterAll: The annotated method will be run once after all the tests in the test class. It's analogous to @AfterClass in JUnit 4.

### 7. Is @BeforeAll method should be Class level(static)?
Yes

### 8.  What is Mockito? and what is its limitations?
Mockito is a popular open-source mocking framework for Java that allows developers to create mock objects and stub their behavior during unit testing. It simplifies the process of creating mock dependencies, defining their behavior, and verifying interactions with those dependencies.

Some key features and benefits of Mockito:

Mocking: Mockito provides mechanisms to create mock objects that simulate the behavior of real objects in a controlled manner. Mock objects are used to replace dependencies of the class under test, enabling isolated testing of specific units.
Stubbing: With Mockito, you can define the behavior of mock objects by specifying return values or exceptions for specific method calls. This allows you to simulate different scenarios and test edge cases without relying on real implementations.
Verification: Mockito offers powerful verification capabilities to verify interactions between the class under test and its dependencies. You can check if specific methods were called, how many times they were called, and with what arguments.
Annotation Support: Mockito supports annotations like @Mock, @Spy, and @InjectMocks to simplify the creation and injection of mock objects in test classes.
Clear and Readable Syntax: Mockito provides a clean and readable syntax, making the test code more expressive and easier to understand.

Despite its many advantages, Mockito has some limitations. It cannot used on final, static, private methods.

Final Classes and Methods: Mockito cannot mock final classes and methods since it uses dynamic proxies and bytecode manipulation, which are not compatible with final elements. However, there are workarounds available, such as using Mockito extensions like Mockito-inline or Mockito with PowerMock.
Static Methods: Mockito cannot directly mock static methods because it relies on instance-based mocking. To mock static methods, you can use additional libraries like PowerMock or consider refactoring your code to make it more testable.
Final Fields: Mockito cannot directly mock final fields. If a class under test has final fields, you may need to use reflection or other techniques to modify the field's value for testing purposes.
Internal Method Calls: Mockito cannot directly mock internal method calls within the same object. It can only mock external dependencies. If you need to mock internal calls, you may need to refactor your code or use different techniques like partial mocking.
Limited Support for Some Complex Scenarios: Mockito may have limited support for certain complex scenarios, such as mocking static initializers, private constructors, or classes that heavily rely on internal state or static state. In such cases, additional libraries or techniques may be required.

### 9.  What is @Mock and what is @InjectMocks?
@Mock:
The @Mock annotation is used to create mock objects of dependencies in a test class. This annotation is used to create and inject mocked instances. The @Mock annotation tells Mockito to mock an instance of the class (or interface) it's annotated on. By annotating a field with @Mock, Mockito automatically creates a mock object for the corresponding type. Mock objects created with @Mock can be stubbed to define their behavior and used to verify interactions during testing. The mock objects are typically injected into the class under test using either @InjectMocks or manually using setter or constructor injection.

@InjectMocks:
This annotation is used to create an instance of the class and inject the mocked dependencies. @InjectMocks creates an instance of the class and injects the mocks that are created with the @Mock (or @Spy) annotations into this instance. The @InjectMocks annotation is used to inject mock objects into a test class. It works in conjunction with the @Mock annotation by automatically injecting the mock objects into the class under test. The injection is performed based on the type of the mock objects and the target class fields or constructor parameters. @InjectMocks can be used when the class under test has dependencies that are mocked using @Mock.

### 10. What is the stubbing?
Stubbing is a technique used in testing to replace real components with fake components (stubs) that mimic the behavior of the real ones. It's used when the real components are impractical to include in a test. Stubbing, in the context of software testing, refers to the process of defining the behavior or response of a mock object or dependency during test execution. When stubbing, you set up the expected return values or exceptions that should occur when specific methods of the mock object are called.

Here are some key points about stubbing:

Creating Expectations: During stubbing, you define the expected behavior of the mock object for a specific method or set of inputs. This includes specifying the return value that the method should provide or the exception that should be thrown.
Controlling Behavior: By stubbing the mock object, you gain control over its behavior in different test scenarios. You can simulate different outcomes, edge cases, or error conditions to thoroughly test the behavior of the class under test.
Isolating Dependencies: Stubbing helps isolate the class under test by replacing its dependencies with mock objects. This allows you to focus on testing the specific functionality of the class without relying on the behavior of external components.
Defining Test Cases: Stubbing plays a crucial role in defining test cases by setting up the expected behavior of dependencies. It allows you to simulate various scenarios and ensure that the class under test interacts correctly with its dependencies.

### 11. what is Mockito ArgumentMatchers
Argument Matchers in Mockito are powerful expressions/utility methods that you can use to make flexible verifications and stubbings. They allow you to specify the arguments that your stubbed methods will accept, or the arguments you expect to be made to a verified method call.

### 12. what is Hamcrest Matchers
Hamcrest is a framework that provides a set of matchers for creating more expressive and readable assertions in unit tests. Hamcrest matchers work seamlessly with popular testing frameworks like JUnit and Mockito, enhancing the clarity and effectiveness of your test code. Hamcrest matchers allow you to construct assertions that closely resemble natural language statements, making it easier to understand the intent of the test. These matchers provide a fluent API for building complex assertions and comparing expected values with actual results.

Here are some examples of commonly used Hamcrest matchers:

equalTo(expectedValue): Matches if the actual value is equal to the expected value.
not(equalTo(unexpectedValue)): Matches if the actual value is not equal to the unexpected value.
greaterThan(comparableValue): Matches if the actual value is greater than the given comparable value.
lessThan(comparableValue): Matches if the actual value is less than the given comparable value.
containsString(substring): Matches if the actual string contains the specified substring.
hasSize(size): Matches if the actual collection or array has the specified size.
instanceOf(classType): Matches if the actual value is an instance of the specified class.
anyOf(matcher1, matcher2): Matches if any of the provided matchers match the actual value.
allOf(matcher1, matcher2): Matches if all of the provided matchers match the actual value.

### 13. do you know @spy? what is difference between @spy and @Mock?
@Mock: This annotation is used to create a mock object of a class or interface. The mock object created using @Mock is a complete replacement of the real object, and its behavior needs to be explicitly defined using Mockito's mocking capabilities (e.g., when(), thenReturn()). Which means the mock object does not have any of its own functionality; instead, you must define the behavior of its methods using Mockito's when(...). By default, all methods of the mock object return default values (e.g., null, 0, false) unless specified otherwise. That is to say, any method you do not explicitly stub out will return a default value (like null, 0, false, etc., depending on the return type). The @Mock annotation is suitable when you want to create a mock object from scratch and define its behavior for the specific test case. thenReturn(...) method. 

@Spy: This annotation is used to create a partial mock object of a real class or object. The spy object created using @Spy retains the behavior of the real object, and only specific methods that you choose to mock will have modified behavior. By default, all methods of the spy object delegate to the real implementation unless you explicitly define the behavior using Mockito's mocking capabilities. Which means, calling methods on the spy will call the real methods (this is unlike a mock, where you have to define the behavior of each method). However, you can still stub out certain methods to have them behave the way you want, just like with a mock. The @Spy annotation is useful when you want to partially mock an existing object, allowing you to verify and modify specific behavior while maintaining the original behavior of the object.

### 14. briefly reading this articles
    a. https://www.javatpoint.com/examples-of-mockito-and-junit-in-eclipse-ide
    b. https://www.javatpoint.com/junit-tutorial
    c.  https://www.javatpoint.com/testng-tutorial
    d.  https://www.javatpoint.com/jmeter-tutorial
    
### 15. Add unit test for CommentServiceImpl, the coverage should be 100%.
 