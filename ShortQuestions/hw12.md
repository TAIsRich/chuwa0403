# 1. List all of the new learned annotations to your annotations.md
# 2. what is selenium(YouTube)?
Selenium is an open-source framework used for automating web browsers. It provides a way to interact with web applications by simulating user actions such as clicking buttons, filling out forms, and navigating through pages. Selenium supports various programming languages and can be used for tasks like web scraping, automated testing, and web application development.
# 3. what is cucumber(youtuebe)?
Cucumber is an open-source tool that supports behavior-driven development (BDD). It allows software teams to define, document, and automate the testing of application features in a human-readable format.
# 4. what is JMeter(youtube)?
JMeter is an open-source performance testing tool developed by Apache. It is primarily used to measure and analyze the performance of web applications and services. JMeter allows you to simulate various user scenarios by sending requests to a target server, such as HTTP or FTP requests, and measuring the response times and throughput. It supports features like load testing, stress testing, and functional testing. JMeter can generate detailed reports and graphs to help identify performance bottlenecks and optimize application performance. It is widely used by developers and testers to ensure that web applications can handle high loads and perform well under different conditions.
# 5. what is unit-test?
A unit test is a type of software testing that focuses on testing the smallest units of an application, typically individual functions or methods. The purpose of unit testing is to verify that each unit of code (e.g., a function) behaves correctly and produces the expected output for a given set of inputs.
# 6. What is the lifecircle of Junit?
- Test Lifecyle Phases
- Before And After Annotations
- Disabling Tests
- Assertions
- Assumptions
# 7. Is @BeforeAll method should be Class level(static)?
Yes.
# 8. What is Mockito? and what is its limitations?
Mockito provides an easy-to-use API for creating mock objects, defining their behavior, and verifying interactions with them. It simplifies the creation of test doubles, such as mocks or stubs, by providing methods to mock method calls, set return values, and verify method invocations.

Limitations:
- Mockito cannot mock final classes or methods, nor can it mock static methods.
- Mockito cannot directly mock private methods.
- Mockito can sometimes be misused to create overly complex tests or tightly coupled code.
# 9. What is @Mock and what is @InjectMocks?
The @Mock annotation is used to create a mock object of a class or interface.

The @InjectMocks annotation is used to inject mock objects into the code under test. It allows Mockito to automatically inject the mocks into the fields or parameters of the test class where the @InjectMocks annotation is applied.
# 10. What is the stubbing?
Stubbing, in the context of testing, refers to the process of defining predetermined behavior or return values for methods or functions of a mock object or stub object. It allows developers to simulate the behavior of dependencies or collaborators in a controlled manner during unit testing.
# 11. what is Mockito ArgumentMatchers
Mockito ArgumentMatchers is a utility class provided by Mockito to match and handle arguments passed to mocked methods during test execution. It offers a set of static methods that assist in defining argument matching rules and expectations for method invocations on mock objects.
# 12. what is Hamcrest Matchers
Hamcrest Matchers is a framework for writing flexible and readable assertions in Java tests. It provides a set of matchers that allow developers to express expected outcomes in a more expressive and fluent manner.

Hamcrest matchers work by wrapping the actual value being tested and providing methods to perform various assertions and match against expected conditions. These matchers can be used with testing frameworks like JUnit, TestNG, and Mockito, among others.
# 13. do you know @spy? what is difference between @spy and @Mock?
@Spy is used for partial mocking of an existing object, retaining some original behavior. @Mock creates a fully mocked object with no real behavior by default.