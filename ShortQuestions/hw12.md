# 1. List all of the new learned annotations to your annotations.md 
# 2. what is selenium(YouTube)? 
"Selenium" is commonly known as a popular open-source framework used for automating web browsers.It allows developers to write scripts in various programming languages (such as Python, Java, C#, etc.) to interact with web applications and perform tasks such as filling out forms, clicking buttons, navigating through pages, and extracting data.

# 3. what is cucumber(youtuebe)? 
"Cucumber" is a popular open-source tool used for behavior-driven development (BDD) and acceptance testing. It allows collaboration between developers, testers, and business stakeholders to create executable specifications called "feature files" written in a simple and human-readable language.

# 4. what is JMeter(youtube)? 
"JMeter" is a popular open-source software tool developed by Apache that is used for performance testing and load testing of web applications. It is not specifically related to YouTube, but it can be utilized to test the performance and measure the response time of various web services, including YouTube.

# 5. what is unit-test? 

A unit test is a type of software testing that focuses on verifying the correctness of individual units or components of a software application. In unit testing, the smallest testable parts of an application, such as functions, methods, or classes, are tested in isolation to ensure that they work as intended.

# 6. What is the lifecircle of Junit?
JUnit is a popular testing framework for Java applications, and it provides a well-defined lifecycle for executing test cases. The lifecycle of JUnit follows a specific sequence of events when running test methods. Here is an overview of the JUnit test lifecycle:

- Test Class Initialization: JUnit creates a new instance of the test class for each test method. It initializes the test class by invoking the constructor.

- Test Fixture Setup: Before running each test method, JUnit invokes any methods annotated with @BeforeClass once for the entire test class. These methods are typically used to set up any common test fixtures or perform initialization tasks.

- Test Method Initialization: JUnit creates a new instance of the test class for each test method. It initializes the test method by invoking any methods annotated with @Before before executing the actual test method. These methods are used to set up any specific test data or prepare the environment.

- Test Method Execution: JUnit executes the actual test method, which is typically a method annotated with @Test. This is where the test logic is implemented.

- Assertion and Verification: During the test method execution, assertions are used to verify the expected behavior of the code under test. If an assertion fails, the test method is marked as failed, and the test execution continues to the next test method.

- Test Method Cleanup: After the test method execution, JUnit invokes any methods annotated with @After. These methods are used for cleaning up any resources used during the test or resetting the environment.

- Test Fixture Cleanup: After running all test methods in the test class, JUnit invokes any methods annotated with @AfterClass once for the entire test class. These methods are used to clean up any common test fixtures or perform finalization tasks.

# 7. Is @BeforeAll method should be Class level(static)? 
Yes, in JUnit 5, the @BeforeAll annotation should be used at the class level and requires the annotated method to be static.

The @BeforeAll annotation is used to mark a method that should be executed once before all the test methods in a test class. It is typically used for setting up any common test fixtures or performing initialization tasks that are shared among all test methods in the class.

Since @BeforeAll runs before any instance of the test class is created, the method annotated with @BeforeAll must be declared as static. This is because static methods can be invoked without creating an instance of the class.

# 8. What is Mockito? and what is its limitations? 
Mockito is a popular open-source Java framework used for creating mock objects in unit tests. It provides a simple and flexible API for mocking dependencies and behavior of objects during testing, enabling developers to isolate the code being tested from its dependencies.

Mockito allows developers to create mock objects that simulate the behavior of real objects, allowing them to define specific responses, verify method invocations, and set expectations for interactions. With Mockito, developers can focus on testing a specific unit of code without the need for complex setup or integration with actual dependencies.

# 9. What is @Mock and what is @InjectMocks? 
@Mock and @InjectMocks are annotations provided by the Mockito framework to facilitate the creation of mock objects and the injection of those mocks into the class under test.
- The @Mock annotation is used to create a mock object of a class or interface. It is typically used in test classes to define the dependencies or collaborators of the class being tested. When a test class is annotated with @RunWith(MockitoJUnitRunner.class) or uses the MockitoExtension (in JUnit 5), the @Mock annotation initializes the mock object automatically.
- The @InjectMocks annotation is used to inject the mock objects created with @Mock into the class under test. It automatically injects the mocks based on type or name matching. It is typically used in conjunction with @RunWith(MockitoJUnitRunner.class) or the MockitoExtension (in JUnit 5) to automatically inject the mocks.

# 10. What is the stubbing? 
Stubbing, in the context of software testing, refers to the technique of defining predetermined behavior for a method or function in a test double or mock object. It involves specifying the expected return values or behaviors of methods or functions that are called during the execution of a test case.

When stubbing a method or function, the goal is to simulate the behavior of a real object and define the responses it should provide when called. By doing so, stubbing allows developers to control the behavior of dependencies and isolate the code being tested.

# 11. what is Mockito ArgumentMatchers 
Mockito ArgumentMatchers is a feature provided by the Mockito framework to match and handle method arguments during stubbing or verification in mock objects. It allows developers to define flexible and expressive matching criteria for method invocations on mock objects.

Mockito ArgumentMatchers provides a set of static methods that can be used to specify the expected arguments when stubbing or verifying method calls. These methods help define conditions or patterns for matching method arguments.

# 12. what is Hamcrest Matchers 
Hamcrest Matchers is a library that provides a set of matchers for performing flexible and expressive assertions in unit tests. It is commonly used in conjunction with testing frameworks like JUnit and Mockito to enhance the readability and maintainability of test code.

Hamcrest Matchers offers a wide range of matchers that allow developers to make assertions on various types of objects and their properties. These matchers provide a more readable and fluent syntax for expressing expectations in tests, making the test code more expressive and descriptive.

# 13. do you know @spy? what is difference between @spy and @Mock? 
In Mockito, @Spy is an annotation used to create a partial mock object. It is similar to @Mock, but with one crucial difference: @Spy creates a real instance of the class being annotated, while @Mock creates a mock object.

# 14. briefly reading this articles
    * https://www.javatpoint.com/examples-of-mockito-and-junit-in-eclipse -ide 
    * https://www.javatpoint.com/junit-tutorial 
    * https://www.javatpoint.com/testng-tutorial 
    * https://www.javatpoint.com/jmeter-tutorial 
# 15. Add unit test for CommentServiceImpl, the coverage should be 100%. 
Write down in local redbook project.