# hw 12 Testing
### 1 Annotations
see annotation [annotations](/ShortQuestions/annotations.md)
### 2 selenium
Selenium is an open source framework used for automating web browsers. It provides a set of tools and libararies that enable developers to write sutomated test and perform browser automation tests.

### 3 cucumber
Cumber is an open source framework that support BDD. It provides way for developers, testers to collaborate and define application behavior in a human-readable format. Cucumber allows the creation of executable specifications written in plaint text format called Gherkin.

### 4 JMeter
JMeter is an open-source performance testing tool designed to measure the performance and load cappabilities of web applications, services, and servers. It allows to simulate multiple users, requests, and various scenarios to asscess the performance, scalability, and stability of a target system.

### 5 unit-test
Unit testing is a software testing technique that focuses on testing individual units or components of a software system in isolation. A unit refers to the smallest testable part of an application, typically a single function, method, or class. The purpose of unit testing is to verify that each unit of the software performs as expected and produces the correct output given a set of inputs.

### 6 lifecycle of Junit
- Set up: put the test infrastructure in place. JUnit provides class level setup @BeforeAll and method level setup @BeforeEach. Generally, heavey objects like database connections are created in class level setup while lightweight objects like test objects are reset in the method level setup
- Test Execution: the test execution and assertion happen. The execution result will signify a success or failure.
- Cleanup: this phase is used to clean up the test infrastructure setup in the first phase. Just like setup, teardown also happen at class level @AfterAll and method level @AfterEach
### 7 
@BeforeAll method should be class level
### 8 Mockito
Mockito is a popular open-source Java testing framework that provides support for creating mock objects in unit test. It allows you to create and configure mock objects that mimic the behavior of read objects, enabling you to isolate and test specific components of your code in a controlled manner.
Mockito is a tools used to mock the function that is not going to be tested in a function.

It cannot used on final, static, private methods.

### 9
@Mock used to create a mock object of a class or interface.

@InjectMocks used on the objects which includes the mock objects and will inject the mock objects into itself. 

The @InjectMocks annotation is used to inject mock objects into the fields of the unit under test. When you annotate a field or a method parameter with @InjectMocks, Mockito will attempt to inject the mock objects created with @Mock into the fields of the class under test automatically. The injection is done based on type matching, so the names of the mock objects and the fields in the class under test should match.
### 10 stubbing
Stubbing refers to the process of defining the behavior of a mock object in a test scenario. When stub a method, you are specifying what the method should return or how it should behave when it is invoked during the test. This allows to control the behavior of dependencies and focus on testing specific scenarios without relying on the actual implementation of those dependencies.

In the context of mocking frameworks like Mockito, stubbing is commonly used to set up the behavior of mock objects.
### 11 Mockito ArgumentMatchers
Mackito ArugmentMatchers are utility methods provided by the Mockito mocking framework to specify the matching criteria for method arguments when stubbing or verifying method invocations on mock objects. 
### 12 Hamcrest Matchers
Hamcrest Matchers is a library that provides a set of matchers for creating expressive and readable assertions in your tests. It works well with testing frameworks like JUnit and Mockito, allowing you to write assertions that are more human-readable and intuitive.
### 13
@Spy: The @Spy annotation is used to create a partial mock object of a real class or object. The spy object created using @Spy retains the behavior of the real object, and only specific methods that you choose to mock will have modified behavior. By default, all methods of the spy object delegate to the real implementation unless you explicitly define the behavior using Mockito's mocking capabilities. The @Spy annotation is useful when you want to partially mock an existing object, allowing you to verify and modify specific behavior while maintaining the original behavior of the object.

@Mock: The @Mock annotation is used to create a mock object of a class or interface. The mock object created using @Mock is a complete replacement of the real object, and its behavior needs to be explicitly defined using Mockito's mocking capabilities (e.g., when(), thenReturn()). By default, all methods of the mock object return default values (e.g., null, 0, false) unless specified otherwise. The @Mock annotation is suitable when you want to create a mock object from scratch and define its behavior for the specific test case.

### 14
### 15
