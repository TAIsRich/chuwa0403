# HW 12

## 2. What is selenium?

The primary use of Selenium is web testing and automation. It allows developers and testers to write scripts that simulate user interactions with web browsers, such as clicking buttons, filling out forms, and navigating between pages. These scripts can be executed repeatedly to test web applications for functionality, compatibility, and regression.

## 3. What is cucumber?

Cucumber is an open-source testing tool that facilitates Behavior Driven Development (BDD). It allows collaboration between developers, testers, and business stakeholders to create and execute automated acceptance tests for software systems.

Cucumber uses a plain-text, human-readable format called Gherkin to define test cases. Gherkin uses a structured language to describe system behavior in terms of scenarios and steps. These scenarios represent different use cases or user stories, and the steps outline the actions to be performed and the expected outcomes.

## 4. What is JMeter?

JMeter allows you to simulate a large number of users or virtual users, known as threads, to generate a heavy load on a target system, such as a web application or web service. It measures and analyzes the system's performance and behavior under different loads, helping identify performance bottlenecks, scalability issues, and other problems.

## 5. What is unit-test?

Unit testing involves the testing of each unit or an individual component of the software application. The purpose is to validate that each unit of the software code performs as expected. Unit testing is done during development of an application by the developers. Unit may be a anindividual function, method, procedure, module and object.

1. Isolation: Unit tests should be isolated from dependencies on other units or external resources. This is often achieved by using test doubles such as mock objects or stubs to simulate the behavior of dependencies.
2. Atomicity: Unit tests should focus on testing a single unit at a time. They should be small, focused, and test a specific behavior or functionality of the unit.
3. Determinism: Unit tests should produce deterministic results, meaning they should give the same result when executed multiple times under the same conditions.
4. Independence: Unit tests should be independent of each other, meaning the execution order of tests should not affect their results.
5. Fast Execution: Unit tests should execute quickly, allowing developers to run them frequently during development and integration processes.

## 6. What is the life circle of Junit?

1. Class Level Setup: @BeforeAll
2. Set Up: @BeforeEach
3. Test Execution: @Test
4. Clean Up: @AfterEach
5. Class Level Clean Up: @AfterAll

## 7. Should @BeforeAll method be Class level(static)?

Yes, all methods annotated with @BeforeAll need to be static methods. Because this is a class level set up.

## 8. What is Mockito? What are its limitations?

The main purpose of Mockito is to create mock objects that simulate the behavior of real objects or dependencies within a software system. These mock objects can be used to replace actual implementations of dependencies, such as databases, network services, or external APIs, during unit testing. By using mock objects, developers can isolate the unit being tested and focus on specific behaviors or scenarios without involving the real implementations.

Limitations:

1. Can't mock private methods.
2. Can't mock static methods.
3. Can't mock final classes and method.
4. Can't mock unreachable code.
5. Can't handle complex frameworks.
6. Over-mocking and code maintainability.

## 9. What is @Mock and what is @InjectMocks?

1. `@Mock` Annotation: The `@Mock` annotation is used to create mock objects for the dependencies of the class under test. When a class is annotated with `@Mock`, Mockito creates a mock object instance of that class, which can be used to define the behavior of its methods during testing.
2. `@InjectMocks` Annotation: The `@InjectMocks` annotation is used to automatically inject the mock objects created with `@Mock` into the class under test. It tells Mockito to inject the mocked dependencies into the fields of the class being tested.

## 10. What is the stubbing?

The process of defining specific behavior or return values for methods or functions of a mock object or dependency.

When stubbing, developers set up the expectations for a method or function call and specify the desired behavior or return value. This allows them to control the response of the mocked object during the test and isolate the unit under test from the actual implementation of its dependencies.

## 11. What is Mockito ArgumentMatchers?

A feature provided by the Mockito framework that allows developers to define flexible and expressive argument matching in their mock interactions. ArgumentMatchers provide a way to specify conditions for the method arguments passed to mocked object methods.

By using ArgumentMatchers, developers can match and handle different argument types, such as specific values, any value, null values, collections, or custom matchers. This flexibility enables precise mocking and verification of method calls with various argument combinations.

## 12. What is Hamcrest Matchers?

A library that provides a wide range of matchers for performing flexible and expressive assertions in unit tests. It works in conjunction with testing frameworks like JUnit and provides a set of reusable matchers that enable developers to create readable and maintainable test assertions.

Hamcrest Matchers follows a fluent and human-readable syntax, allowing tests to be written in a more natural language style. It aims to improve the readability of test code by providing intuitive matchers for various data types and conditions.

```java
import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.*;

import org.junit.Test;

public class ExampleTest {

    @Test
    public void testMethod() {
        String message = "Hello, world!";
        int count = 5;
        double value = 10.5;

        assertThat(message, startsWith("Hello"));
        assertThat(count, greaterThan(0));
        assertThat(value, closeTo(10.0, 0.1));
    }
}

```

## 13. Do you know @Spy? what is difference between @Spy and @Mock?

The `@Spy` annotation, like `@Mock`, is used in conjunction with the Mockito framework for creating and working with test doubles. However, there is a fundamental difference between the two annotations.

 `@Mock` creates a blank slate object with no real implementation. While A spy is a real instance of a class that is partially mocked, meaning some of its methods are stubbed while others retain their original behavior. 