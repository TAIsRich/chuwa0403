# HW12

1. List all of the new learned annotations to your annotations.md

   

2. what is selenium(YouTube)?

   Selenium is a popular open-source framework used for automating web browsers. It is primarily used for automating web applications for testing purposes.

   

3. what is cucumber(youtuebe)?

   Cucumber allows you to write test cases that anyone can easily understand regardless of their technical knowledge. These test cases, known as "features", are written in a simple language called Gherkin that uses a business-readable, domain-specific language. The format typically follows a Given-When-Then structure.

   

4. what is JMeter(youtube)?

   JMeter is an open-source software tool designed for load testing and measuring the performance of web applications, among other services. It was developed by the Apache Software Foundation and is written in Java, which means it is platform-independent and can run on any system that supports Java.

   

5. what is unit-test?

   Unit testing is a type of software testing where individual components of a software are tested. The purpose is to validate that each unit of the software performs as designed.

   A unit is the smallest testable part of any software. It usually has one or a few inputs and typically a single output. In object-oriented programming, a unit could be an entire interface, such as a class, but it could also be an individual method. Unit tests are typically written and run by software developers to ensure that code meets its design and behaves as intended.

   

6. What is the lifecircle of Junit?

   1. **@BeforeAll**: This annotation denotes that the annotated method will be run once before any of the test methods in the class. This is typically used for setting up expensive test fixtures, connecting to a database, setting up network connections, etc. It must be a static method.

   2. **@BeforeEach**: This annotation indicates that the annotated method will be run before each test method. This is used for setting up the test environment, such as initializing variables, clearing certain states, etc.

   3. **@Test**: The @Test annotation indicates a method is a test method. This method contains the code that actually tests the functionality of the class or method in question.

   4. **@AfterEach**: The @AfterEach annotation is used to indicate that the annotated method will be run after each test method. This is typically used for clean-up activities, such as closing database connections, clearing states, etc.

   5. **@AfterAll**: The @AfterAll annotation denotes that the annotated method will be run once after all test cases have been run. It is used to clean up the expensive setup initialized with @BeforeAll. It must be a static method.

      

7. Is @BeforeAll method should be Class level(static)?

   Yes, the `@BeforeAll` annotation in JUnit 5 is intended to be used with static methods. The method marked with this annotation will be executed once before all of the tests in the class are run.

   

8. What is Mockito? and what is its limitations?

   Mockito is a popular open-source testing framework for Java that is used for writing unit tests with mocks. Mocking is a technique in test-driven development where a real object is replaced with a fake object, a "mock", that simulates the behavior of the real object.

   Mockito allows you to create and configure mock objects. Using Mockito, you can verify that certain methods were called on these mock objects, you can stub method calls and return specific values, and you can examine the interactions between the mock objects and the object under test.

   Here are some of the limitations of Mockito:

   1. **Cannot Mock Final Classes and Methods**: By default, Mockito cannot mock final classes and methods. This has been a major limitation, but starting with Mockito 2.1.0 (released in late 2016), this is no longer the case if you use the opt-in Mockito extension mechanism.
   2. **Cannot Mock Static Methods**: Mockito can't mock static methods. However, as of Mockito 3.4.0, this feature has been added, but it's still in an incubating state which means that the API could change in future releases.
   3. **Cannot Mock Constructors**: Mockito cannot mock constructors. If you need to mock the creation of new objects, you may need to refactor your code to make it more testable or use a mocking library that supports this, like PowerMock (although, in general, this is often considered a bad practice because it can lead to brittle tests).
   4. **Does Not Support Spy Objects Very Well**: Although Mockito does allow creating spy objects (real objects with some methods stubbed), using spies can be tricky because the real methods can still be called, which can lead to unexpected side-effects.
   5. **Mockito's Verification Errors are sometimes Hard to Understand**: Mockito's error messages and stack traces are not always clear, making it difficult to understand why a test failed.
   6. **Mockito Doesn't Encourage Interaction Testing**: Mockito is a tool that encourages developers to verify interactions between objects in the system under test. This can be seen as a limitation because often it's more important to focus on the observable state changes and returned results of the object under test rather than verifying its interactions with mocks.

   

9. What is @Mock and what is @InjectMocks?

   **@Mock**: This annotation is used to create a mock object of a class or an interface. When you use `@Mock`, Mockito creates a dummy instance of the class (or interface) it is annotating. The mock object replaces the real object. It can be programmed to perform specific behaviors during a test, such as returning specific values or throwing an exception when a particular method is called.

   **@InjectMocks**: This annotation is used to create an instance of the class and inject the mocks created using `@Mock` (or `@Spy`) into it. Mockito will try to inject mocks either by constructor injection, setter injection, or property injection (in this order) â€” depending on what's applicable.

   

10. What is the stubbing?

    Stubbing is a concept in software testing where we create "stubs," which are simple implementations of interfaces or classes that return fixed data. Stubs are used in unit testing to simulate the behavior of complex components that the code under test interacts with. By using stubs, you can create controlled and predictable conditions for your tests, isolate your code from its dependencies, and focus on testing your code's logic.

    

11. what is Mockito ArgumentMatchers

    In Mockito, Argument Matchers are used when we do not care about the specific argument's value when stubbing a method call or verifying interactions.

    Instead of using a specific argument when calling a method on a mock object, we can use argument matchers to generalize the arguments. Mockito provides several built-in matchers we can use, such as `any()`, `eq()`, `anyInt()`, `anyString()`, etc.

    

12. what is Hamcrest Matchers

    Hamcrest is a framework for writing matcher objects allowing 'match' rules to be defined declaratively. It's often used in unit testing frameworks like JUnit and Mockito to build more flexible tests and improve the readability of the test assertions.

    

13. do you know @spy? what is difference between @spy and @Mock?

    1. **@Spy**: This annotation is used to create a spy of a real object. A spy is a copy of the real object that retains the original methods and properties, but also allows you to stub and verify method calls just like a mock. When you spy on an object, the real methods are called unless they are explicitly stubbed.

    2. **@Mock**: This annotation is used to create a mock object. Unlike a spy, a mock does not retain any behavior of the original object; instead, it allows you to define all of the behavior directly. When you call a method on a mock object, it returns a default value unless it has been explicitly stubbed.

       

14. briefly reading this articles

    1. https://www.javatpoint.com/examples-of-mockito-and-junit-in-eclipse -ide
    2. https://www.javatpoint.com/junit-tutorial
    3. https://www.javatpoint.com/testng-tutorial
    4. https://www.javatpoint.com/jmeter-tutorial

    

15. Add unit test for **CommentServiceImpl**, the coverage should be **100%**.