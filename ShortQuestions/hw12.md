## 1. List all of the new learned annotations to your annotations.md
check annotations.md.


## 2. what is selenium(YouTube)?

Selenium is a popular open-source framework used for automating web browsers. It provides a set of tools and libraries that allow you to control web browsers programmatically and perform various actions on web applications.

Selenium supports multiple programming languages such as Java, Python, C#, and more, making it accessible to developers from different backgrounds. It allows you to write scripts or code to interact with web elements, simulate user actions like clicking buttons or filling out forms, navigate through web pages, and perform automated testing of web applications.


## 3. what is cucumber(youtuebe)?
Cucumber is a testing tool and a behavior-driven development (BDD) framework that allows you to write tests in a human-readable format. It enables collaboration between business stakeholders, developers, and testers by providing a common language for expressing the behavior of a system.

Cucumber uses a simple syntax called Gherkin, which is a structured natural language format that describes the expected behavior of a software system. Gherkin scenarios are written in feature files and consist of steps that define the interactions between various components of the system.


## 4. what is JMeter(youtube)?

Apache JMeter is an open-source performance testing tool designed to load test functional behavior and measure performance of web applications. It is primarily used for testing the performance and scalability of web applications, but can also be used to test other types of software systems.

JMeter allows you to simulate various types of loads on a web application, including high concurrent user traffic, heavy server loads, and stress conditions. It generates and sends HTTP requests to the target application, measures the response time, throughput, and other performance metrics, and provides detailed reports and analysis of the test results.

Key features of JMeter include:

Test plan creation: JMeter allows you to create a test plan that defines the structure and configuration of the tests. This includes defining the target application, specifying the load scenario, setting up thread groups, and configuring samplers, timers, and assertions.

Load generation: JMeter simulates user behavior by generating and sending HTTP requests to the target application. It can generate high volumes of requests concurrently, mimicking real-world user traffic.

Performance monitoring: During the test execution, JMeter collects performance metrics such as response time, throughput, latency, and error rates. It provides real-time monitoring and analysis of these metrics to identify performance bottlenecks and issues.

Assertions and validations: JMeter allows you to define assertions to validate the responses from the target application. These assertions help ensure the correctness and consistency of the application's behavior during the test.

Reporting and analysis: JMeter generates detailed test reports and analysis that include performance metrics, graphs, and charts. These reports help in identifying performance bottlenecks, analyzing the system's capacity, and making performance-related decisions.

## 5. what is unit-test?
A unit test is a type of software testing where individual units, such as methods or functions, are tested to verify that they behave as expected. The goal of unit testing is to isolate each unit of the software and validate its correctness and reliability in isolation, independent of other units or external dependencies.

Unit tests are typically written by developers and are executed during the development process to ensure that each unit of code functions correctly. They form the foundation of automated testing and are a fundamental part of test-driven development (TDD) and agile development practices.


## 6. What is the lifecircle of Junit?
The lifecycle of JUnit involves several stages that are executed in a specific order when running tests. Here is a high-level overview of the lifecycle of JUnit:

`Test Setup`: Before each test case is executed, JUnit invokes the @Before annotated method (if present) to set up any necessary test fixtures or preconditions. This method is typically used to initialize objects, open connections, or perform any other necessary setup steps.

`Test Execution`: The actual test case is executed by invoking the test method annotated with @Test. JUnit creates a new instance of the test class for each test method and executes the test method in isolation.

`Test Assertions`: Within the test method, developers use various assertion methods provided by JUnit, such as assertEquals, assertTrue, or custom assertions, to verify the expected behavior of the code being tested. If any assertion fails, the test is marked as a failure.

`Test Teardown`: After each test case is executed, JUnit invokes the @After annotated method (if present) to perform any necessary cleanup or teardown operations. This method is typically used to release resources, close connections, or perform other cleanup tasks.

`Test Suite`: JUnit allows grouping multiple test cases into test suites using the @RunWith and @Suite annotations. Test suites provide a way to organize and execute multiple test cases together.

`Test Result Reporting`: As the tests are executed, JUnit collects information about the test results, including the number of tests run, passed, failed, and the time taken for execution. The test results are typically reported in a summary format, indicating the overall success or failure of the test run.

`Test Coverage`: JUnit can also integrate with code coverage tools, such as JaCoCo, to measure the code coverage achieved by the tests. Code coverage reports provide insights into the portions of code that have been exercised by the tests and help identify areas that require additional testing.


## 7. Is @BeforeAll method should be Class level(static)?
Yes, the `@BeforeAll` method in JUnit 5 should be declared as a static method at the class level. The `@BeforeAll` annotation is used to mark a method that should be executed once before any of the test methods in the class are run.

Since `@BeforeAll` is executed before any test instance is created, it requires the method to be static. This ensures that the method can be called without the need for an instance of the test class.

Here's an example of how to use `@BeforeAll` in JUnit 5:
```java
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

class MyTestClass {

    @BeforeAll
    static void setup() {
        // Perform setup actions here
    }

    @Test
    void myTest() {
        // Test code here
    }

    // Additional test methods...
}
```

In the example above, the `setup()` method is annotated with `@BeforeAll` and declared as static. It will be executed once before any of the test methods in the MyTestClass are run.

Note that `@BeforeAll` methods cannot be overridden or inherited, and they must not be declared in non-static inner classes.


## 8. What is Mockito? and what is its limitations?
Mockito is a popular Java mocking framework used for unit testing. It allows you to create mock objects, also known as test doubles, which simulate the behavior of real objects in controlled ways. Mockito provides a simple and intuitive API for creating and configuring mock objects, stubbing methods, verifying method invocations, and more.

Mockito is widely used in conjunction with testing frameworks like JUnit and TestNG to create isolated unit tests. It helps developers write focused tests by isolating the unit under test and providing controlled behavior for its dependencies.

Some limitations of Mockito include:

`Final classes and methods`: Mockito cannot mock final classes or methods. It is because Mockito works by creating dynamic proxy objects or subclassing the mocked classes. Final classes and methods cannot be subclassed or overridden, making them unmockable by default.

`Static methods`: Mockito cannot directly mock static methods. Static methods are associated with the class itself, not with instances, and Mockito primarily works with instances. However, there are other libraries like PowerMock that can handle mocking of static methods.

`Constructors`: Mockito cannot directly mock constructors. It is because Mockito works with instances of classes, and the creation of instances involves constructors. However, there are ways to work around this limitation using techniques like dependency injection or factory methods.

`Partial mocking of classes`: Mockito does not support partial mocking of classes, meaning you cannot mock only certain methods of a class while keeping the others intact. Mockito mocks the entire class, replacing all methods with its own behavior.


## 9. What is @Mock and what is @InjectMocks?

In the context of the Mockito framework, `@Mock` and `@InjectMocks` are annotations used for dependency injection and mocking in unit tests.

`@Mock`: The `@Mock` annotation is used to create a mock object for a class or interface. It tells Mockito to create a mock implementation of the annotated class or interface. This allows you to define the behavior of the mock object and verify interactions with it during the test. You can use `@Mock` in conjunction with Mockito.mock() or MockitoAnnotations.initMocks() to initialize the mock objects.
```java
@Mock
private UserService userService;
```

`@InjectMocks`: The `@InjectMocks` annotation is used to inject the mock objects created with @Mock into the instance of the class being tested. It tells Mockito to inject the mock objects into the fields or constructor parameters of the test class. This simplifies the process of setting up the dependencies for the class under test.
```java
@InjectMocks
private UserController userController;
```

## 10. What is the stubbing?
Stubbing, in the context of testing and mocking frameworks, refers to the process of defining the behavior of a mock object. It involves setting up predefined responses or return values for specific method calls on the mock object.

When you stub a method, you are essentially providing a fixed response that the mock object should return when that method is called during the test. This allows you to simulate the behavior of a real object and control the outcome of the method invocation.

Stubbing is commonly used in unit testing scenarios where you want to isolate the unit under test from its dependencies. By stubbing the dependencies, you can ensure that the unit being tested operates as expected without relying on the actual implementation or behavior of the dependencies.

Mocking frameworks like Mockito provide convenient APIs for stubbing methods on mock objects. Using these frameworks, you can specify the expected method calls and their corresponding return values or exceptions. This allows you to create controlled test scenarios and verify the behavior of the code being tested.

```java
// Create a mock object
MyService myService = Mockito.mock(MyService.class);

// Stub the behavior of the mock object
Mockito.when(myService.doSomething()).thenReturn("Mocked Result");

// Invoke the method on the mock object
String result = myService.doSomething();

// Verify the result
Assert.assertEquals("Mocked Result", result);
```
In this example, the `doSomething()` method of the `MyService` mock object is stubbed to always return the string `"Mocked Result"`. When the method is invoked during the test, it will return the stubbed value instead of executing the actual implementation of the method.


## 11. what is Mockito ArgumentMatchers

Mockito ArgumentMatchers are utility methods provided by the Mockito framework to match and specify arguments when stubbing or verifying method invocations on mock objects. These matchers allow you to define flexible and dynamic behavior based on the arguments passed to the method.

ArgumentMatchers can be used in conjunction with Mockito methods like `when()` and `verify()` to define the expected arguments for method invocations.

Here are some commonly used Mockito ArgumentMatchers:

`any()`: Matches any argument of any type. For example, `when(myMock.someMethod(any())).thenReturn("Mocked Result")` will stub the `someMethod()` to return `"Mocked Result"` regardless of the argument passed.

`eq(value)`: Matches an argument that is equal to the specified value. For example, `when(myMock.someMethod(eq("Test"))).thenReturn("Mocked Result")` will stub the someMethod() to return `"Mocked Result"` only when the argument is equal to "Test".

`anyInt()`, `anyString()`, `anyBoolean()`, etc.: Matches arguments of specific types. For example, `when(myMock.someMethod(anyInt())).thenReturn(42)` will stub the `someMethod()` to return `42` for any integer argument.

`argThat(matcher)`: Matches an argument based on a custom matcher. You can provide your own implementation of ArgumentMatcher to define complex matching logic.

```java
// Create a mock object
MyService myService = Mockito.mock(MyService.class);

// Stub the behavior of the mock object using argument matchers
Mockito.when(myService.doSomething(anyString())).thenReturn("Mocked Result");

// Invoke the method on the mock object with different arguments
String result1 = myService.doSomething("Test");
String result2 = myService.doSomething("Another");

// Verify the results
Assert.assertEquals("Mocked Result", result1);
Assert.assertEquals("Mocked Result", result2);
```

## 12. what is Hamcrest Matchers
Hamcrest Matchers is a library that provides a set of matchers for creating expressive and readable assertions in unit tests. It enhances the readability of test code by providing a fluent and descriptive syntax for writing assertions.

Hamcrest Matchers can be used in conjunction with testing frameworks like JUnit or Mockito to create more meaningful assertions. The library includes a wide range of matchers that cover various data types and conditions.

Some examples of commonly used Hamcrest Matchers include:

`equalTo(expected)`: Matches if the actual value is equal to the expected value.
`is(expected)`: Matches if the actual value is equal to the expected value.
`not(value)`: Matches if the actual value is not equal to the specified value.
`greaterThan(value)`, `lessThan(value)`: Matches if the actual value is greater than or less than the specified value.
`startsWith(prefix)`, `endsWith(suffix)`: Matches if the actual value starts with or ends with the specified prefix or suffix.
`containsString(substring)`: Matches if the actual value contains the specified substring.
`hasItem(item)`: Matches if the actual collection contains the specified item.
`hasProperty(propertyName, valueMatcher)`: Matches if the actual object has a property with the specified name and value matching the provided matcher.

By using Hamcrest Matchers, you can write more expressive and readable assertions in your unit tests, making it easier to understand the expected behavior and outcomes of your code. Here's an example of using Hamcrest Matchers with JUnit:
```java
import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.*;

...

@Test
public void testSomeMethod() {
    int actualValue = 10;
    assertThat(actualValue, is(equalTo(10)));
    assertThat(actualValue, greaterThan(5));
    assertThat("Hello World", containsString("World"));
    List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
    assertThat(numbers, hasItem(3));
    assertThat(numbers, everyItem(greaterThan(0)));
}
```


## 13. do you know @spy? what is difference between @spy and @Mock?
The `@Spy` annotation is used to create a partial mock of an object. It allows you to spy on a real instance of a class, meaning that some methods of the object will be called as usual, while others can be stubbed or verified using Mockito's mocking capabilities.

The main difference between `@Spy` and `@Mock` is how they behave:

`@Mock` is used to create a mock object, where all methods are stubbed by default. You define the behavior of the methods you want to mock explicitly.
`@Spy` is used to create a spy object, where some methods are stubbed and others are not. The real implementation of the object is called for the non-stubbed methods.
In other words, with `@Mock`, all methods are initially mocked and you define the behavior you want. With `@Spy`, the real implementation is called by default, and you can choose which methods to stub or mock.

```java
public class MyClass {
    public int add(int a, int b) {
        return a + b;
    }

    public int multiply(int a, int b) {
        return a * b;
    }
}

//In this case, all methods of myClass are mocked, including both `add()` and `multiply()`.
@RunWith(MockitoJUnitRunner.class)
public class MyClassTest {

    @Mock
    private MyClass myClass;

    @Test
    public void testAdd() {
        Mockito.when(myClass.add(2, 3)).thenReturn(5);
        // ...
    }
}

//With `@Spy`, the real implementation of myClass is called by default, and only the `add()` method is mocked in this example.
@RunWith(MockitoJUnitRunner.class)
public class MyClassTest {

    @Spy
    private MyClass myClass;

    @Test
    public void testAdd() {
        Mockito.when(myClass.add(2, 3)).thenReturn(5);
        // ...
    }
}

```

## 14. briefly reading this articles
a. https://www.javatpoint.com/examples-of-mockito-and-junit-in-eclipse-ide
b. https://www.javatpoint.com/junit-tutorial
c. https://www.javatpoint.com/testng-tutorial
d. https://www.javatpoint.com/jmeter-tutorial



## 15. Add unit test for CommentServiceImpl, the coverage should be 100%.
check file Coding/hw12_test/src/test/java/com/chuwa/redbook/service/impl/CommentServiceImplTest.java



## 1. 看⿊马视频：https://www.bilibili.com/video/BV1LQ4y127n4/?p=22&spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=310561eab1216a27f7accf859bf7f6d9
a. ⾄少看⼀遍
b. Required
i. p1- p14
ii. P30 - p41
c. Optional
i. P17 - p29



## 2. ⼀定要先看⿊马，再看这个。抄代码，看视频（视频在repo的readme中）。https://github.com/TAIsRich/microservices-components/tree/main




