## 1. list all of the new annotations you learned to your annotations.md

Ckeck ShortQuestions/annotations.md

## 2. Document the microservice architeture and components/tools/dependencies

The GAI Gateway routes incoming requests to their corresponding servers. Load balancing is performed by a middleware load balancer, while each server establishes connections to its respective database. In cases where servers require intercommunication, it can be achieved through API calls and message queues. API calls are made using RestTemplate, utilizing Ribbon for load balancing. Message queues can be implemented using Kafka's event-driven model. All components are required to register with the same service registry for efficient discovery. Additionally, a configuration center is employed to manage relevant configurations.

## 3. What are Resilience patterns? What is circuit breaker?

**Resilience patterns** are design patterns and techniques used to build resilient and fault-tolerant systems. They help applications handle and recover from failures, errors, and unpredictable conditions, ensuring that the system remains available and responsive even in the face of adversity. Resilience patterns promote system stability, fault tolerance, and graceful degradation.

**The Circuit Breaker pattern** prevents failures from spreading in distributed systems by adding a protective barrier between the caller and a remote service. It monitors the service's performance and switches between allowing requests and rejecting them based on predefined thresholds. This improves system reliability and prevents cascading failures.

## 4. Read this article, then list the important questions, then write your answers

**1. Write main features of Microservices.**

* Decoupling: Within a system, services are largely decoupled. The application as a whole can therefore be easily constructed, altered, and scalable
* Componentization: Microservices are viewed as independent components that can easily be exchanged or upgraded
* Business Capabilities: Microservices are relatively simple and only focus on one service
* Team autonomy: Each developer works independently of each other, allowing for a faster project timeline
* Continuous Delivery: Enables frequent software releases through systematic automation of software development, testing, and approval
* Responsibility: Microservices are not focused on applications as projects. Rather, they see applications as products they are responsible for
* Decentralized Governance: Choosing the right tool according to the job is the goal. Developers can choose the best tools to solve their problems
* Agility: Microservices facilitate agile development. It is possible to create new features quickly and discard them again at any time.

**2. Write main components of Microservices.**
Containers, Clustering, and Orchestration 

IaC [Infrastructure as Code Conception] 

Cloud Infrastructure 

API Gateway 

Enterprise Service Bus 

Service Delivery 



## 5. how to do load balance in microservice? Write a long Summary by yourself.

Load balancing in microservices is a critical aspect of ensuring scalability, high availability, and optimal performance. It involves distributing incoming requests across multiple instances of a service to effectively utilize resources and handle varying workloads. Several load balancing strategies and technologies can be employed to achieve this goal.

**Load Balancing Strategies:**

* Round Robin: Requests are evenly distributed across service instances in a cyclic manner.
* Weighted Round Robin: Assigns weights to service instances to allocate a proportionate share of requests based on their capacity.
* Least Connection: Routes requests to the service instance with the fewest active connections.
* IP Hashing: Uses the client's IP address to consistently route requests to the same service instance.
* Random: Randomly selects a service instance for each request.
Response Time: Routes requests to the service instance with the lowest average response time.

**Load Balancing Techniques:**

* Hardware Load Balancers: Dedicated hardware devices that distribute network traffic across service instances.
* Software Load Balancers: Software-based solutions that perform load balancing, often deployed as a separate service or part of a service mesh.
* DNS Load Balancing: Utilizes DNS to distribute requests across multiple IP addresses associated with service instances.
* Reverse Proxy Load Balancing: Involves a reverse proxy server that receives requests and forwards them to backend service instances based on load balancing rules.

**Service Discovery and Load Balancing:**

* Service Registry: A centralized registry where microservices register themselves, allowing load balancers to dynamically discover and distribute traffic to available instances.
* Service Mesh: An infrastructure layer that provides service discovery, load balancing, and other features to facilitate communication between microservices.

**Dynamic Load Balancing:**

* Continuous Monitoring: Regularly monitoring service instances to collect metrics and health information, enabling load balancers to make informed decisions.
* Auto Scaling: Scaling service instances up or down based on predefined thresholds or policies to adapt to changing load conditions.
* Adaptive Load Balancing: Modifying load balancing strategies dynamically based on real-time performance data to optimize resource utilization and response times.

**3.Explain the working of Microservice Architecture.**

Clients: Different users send requests from various devices. 

Identity Provider: Validate a user's or client's identity and issue security tokens. 

API Gateway: Handles the requests from clients. 

Static Content: Contains all of the system's content. 

Management: Services are balanced on nodes and failures are identified. 

Service Discovery: A guide to discovering the routes of communication between microservices. 

Content Delivery Network: Includes distributed network of proxy servers and their data centers. 

Remote Service: Provides remote access to data or information that resides on networked computers and devices.

**4.What do you mean by end-to-end microservices testing?**
Usually, end-to-end (E2E) microservice testing is an uncoordinated, high-cost technique that is used to ensure that all components work together for a complete user journey. Usually, it is done through the user interface, mimicking how it appears to the user. It also ensures all processes in the workflow are working properly.

**5.Explain the way to implement service discovery in microservices architecture.**
There are many ways to set up service discovery, but Netflix's Eureka is the most efficient. This is a hassle-free procedure that doesn't add much weight to the application. It also supports a wide range of web applications. A number of annotations are provided by Spring Cloud to make its use as simple as possible and to hide complex concepts.



## 6. How to do service discovery?

**Service Registry:** In this approach, services register themselves with a central registry or directory. The registry acts as a database of available services, including their network location and other metadata. Clients can query the registry to discover and locate the desired services.

## 7. What are the major components of Kafka?

**Producer:** Producers are responsible for publishing data to Kafka topics. They can be any application or system that generates data and sends it to Kafka for processing and storage.

**Topic:** A topic is a category or feed name to which producers publish messages. It represents a specific stream of data within Kafka. Topics are partitioned and replicated across a cluster for scalability and fault tolerance.

**Partition:** A partition is a unit of parallelism and scalability in Kafka. Each topic is divided into one or more partitions, allowing multiple consumers to read from the topic concurrently. Partitions also provide fault tolerance by allowing replicas of each partition to be distributed across different brokers.

**Consumer:** Consumers are applications or systems that read data from Kafka topics. They subscribe to one or more topics and consume messages from the partitions assigned to them. Consumers can process data in real-time or at their own pace.

**Broker:** Brokers are the servers that form the Kafka cluster. They handle the storage, replication, and serving of data. Each broker manages one or more partitions of the topics. Kafka brokers work together to provide fault tolerance, scalability, and high availability.

**ZooKeeper:** Kafka relies on ZooKeeper for maintaining cluster coordination and metadata management. ZooKeeper keeps track of Kafka brokers, topic configurations, partition assignments, and consumer group coordination.

**Consumer Group:** A consumer group is a group of consumers that work together to consume messages from one or more topics. Each partition of a topic is consumed by only one consumer within a consumer group, ensuring parallelism and load balancing.

## 8. What do you mean by a Partition in Kafka?

**Partition:** A partition is a unit of parallelism and scalability in Kafka. Each topic is divided into one or more partitions, allowing multiple consumers to read from the topic concurrently. Partitions also provide fault tolerance by allowing replicas of each partition to be distributed across different brokers.

## 9. What do you mean by zookeeper in Kafka and what are its uses?

In Kafka, ZooKeeper is a distributed coordination service used for managing and maintaining the Kafka cluster. It provides cluster coordination, metadata management, leader election, broker registration, and consumer group coordination. ZooKeeper ensures that the different components of Kafka can work together seamlessly and enables high availability and fault tolerance.

## 10. Can we use Kafka without Zookeeper?

Yes, starting from Kafka version 0.10.0.0, it is possible to run Kafka without a dependency on ZooKeeper by using the Kafka Controller. However, ZooKeeper is still used by some additional features and components in the Kafka ecosystem.

## 11. Explain the concept of Leader and Follower in Kafka.

In Kafka, the leader is the broker responsible for handling all read and write requests for a partition, while followers replicate the leader's data and provide fault tolerance. The leader handles client interactions, and followers replicate the data for redundancy and failover.

## 12. Why is Topic Replication important in Kafka? What do you mean by ISR in Kafka?

Topic replication in Kafka is important for fault tolerance, data redundancy, scalability, and load balancing. ISR (In-Sync Replicas) refers to the subset of replicas that are synchronized and up-to-date with the leader. ISR ensures data consistency and determines eligible replicas for leadership in case of failures.

## 13. What do you understand about a consumer group in Kafka?

A consumer group in Kafka is a group of consumers that work together to consume messages from one or more topics. It allows for parallel processing, load balancing, and fault tolerance. Each consumer is assigned a subset of partitions to read from, and Kafka tracks their progress using offsets.

## 14. How do you start a Kafka server?

**Start ZooKeeper:** Kafka depends on ZooKeeper for coordination, so you need to start a ZooKeeper server first. Run the command zookeeper-server-start.sh config/zookeeper.properties to start ZooKeeper.

**Start Kafka Broker(s):** Once ZooKeeper is running, you can start the Kafka broker(s). Run the command kafka-server-start.sh config/server.properties to start a Kafka broker. If you have a cluster, repeat this step for each broker in the cluster.

**Verify Server Startup:** Check the console output for any error messages during startup. If there are no errors, the Kafka server(s) should be up and running.

## 15. Tell me about some of the real-world usages of Apache Kafka.

Real-time stream processing

Log aggregation and collection

Event-driven architectures

Messaging and integration

Internet of Things (IoT) data ingestion

Commit logs and change data capture.

## 16. Describe partitioning key in Kafka.

In Kafka, a partitioning key is a value associated with a message that determines the target partition. It ensures message ordering, workload distribution, and consumer scalability.

## 17. What is the purpose of partitions in Kafka?

The purpose of partitions in Kafka is to achieve high throughput and scalability. They enable horizontal scaling, concurrent processing, fault tolerance, and ordered message delivery. Each partition can be independently processed and consumed by a consumer within a consumer group, allowing for parallel processing and fault tolerance. Partitions also ensure ordered message delivery within the same partition.

## 18. Differentiate between Rabbitmq and Kafka.

RabbitMQ is a traditional message queuing system that emphasizes guaranteed delivery and supports various messaging patterns. Kafka, on the other hand, is a distributed commit log system designed for high-throughput, fault-tolerant, and real-time data streaming. RabbitMQ is suited for traditional messaging scenarios, while Kafka excels in handling large-scale data streaming and event-driven architectures.

## 19. What are the guarantees that Kafka provides?

Kafka provides guarantees for message persistence, fault tolerance, scalability, ordering of messages within a partition, exactly-once delivery, and high throughput.

## 20. What do you mean by an unbalanced cluster in Kafka? How can you balance it?
An unbalanced cluster in Kafka refers to an uneven distribution of partitions across brokers. To balance the cluster, you can add more brokers, adjust topic replication factor, manually reassign partitions, and monitor the cluster for ongoing balance.

## 21. In your recent project, are you a producer or consumer or both?

Both 

## 22. In your recent project, Could you tell me your topic name?

Orders

## In your recent project, How many brokers do you have? How many partitions for each topic? How many data for each topic.

we have 3 brokers. Each topic is divided into 5 partitions, and the data size for each topic varies.

## 24. In your recent project, which team produce what kind of event to you and you producer what kind of events?

The marketing team produces customer engagement events, while I produce system monitoring events for analytics purposes.

## 25. What is offset?

In Kafka, an offset is a unique identifier that represents the position of a consumer within a partition. It tracks the progress of a consumer in consuming messages from a topic.
