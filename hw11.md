### Q1. List all of the annotations you learned from class and homework to annotaitons.md

see `annotation.md`

### Q2. What is the authentication?

In Spring Security, authentication is the process of verifying the identity of a user. It provides a framework for implementing various authentication mechanisms, such as username/password authentication, token-based authentication, or integration with external authentication providers like LDAP or OAuth. Spring Security handles the authentication process by validating user credentials and granting access to protected resources based on the authentication result.

### Q3. What is the authorization?

Authorization in Spring Security refers to the process of determining whether a user or system is allowed to access a specific resource or perform a particular action. It controls access to protected resources based on the authenticated user's assigned roles or permissions. Spring Security provides a flexible and customizable authorization framework that allows developers to define access control rules using annotations, XML configuration, or programmatic configuration. These rules can be based on roles, permissions, or more complex expressions, ensuring that only authorized users can access specific parts of an application.

### Q4. What is the difference between authentication and authorization?

The main difference between authentication and authorization in Spring Security is their purpose and scope:

1. Authentication: Authentication is the process of verifying the identity of a user. It confirms whether the user is who they claim to be. Spring Security provides various authentication mechanisms to validate user credentials, such as username/password authentication, token-based authentication, or integration with external authentication providers. The goal of authentication is to establish the identity of the user before granting access to protected resources.

2. Authorization: Authorization, on the other hand, is the process of determining whether a user or system is allowed to access a specific resource or perform a particular action. It controls access to protected resources based on the authenticated user's assigned roles or permissions. Spring Security's authorization framework enables developers to define access control rules that determine which users or roles have access to specific parts of an application. The goal of authorization is to ensure that only authorized users can perform specific actions or access certain areas of the application.

In summary, authentication is about verifying the identity of a user, while authorization is about granting or denying access to specific resources or actions based on the user's identity and assigned roles or permissions.

### Q5. What is HTTP Session?

HTTP Session is a mechanism used to maintain stateful communication between a web server and a client over multiple requests and responses within an HTTP protocol-based application. It allows the server to associate a set of data with a particular client, typically identified by a session ID.

When a client accesses a web application, the server creates a unique session for that client and assigns it a session ID. The session ID is usually stored as a cookie in the client's browser or included in the URL for subsequent requests.

The server can store and retrieve data specific to each session, known as session attributes. These attributes can be used to maintain user-specific information, such as authentication details, shopping cart contents, or user preferences. The server can access the session attributes using the session ID provided by the client.

HTTP Session provides a way to maintain user context and store temporary data throughout a user's interaction with a web application. It helps enable features such as user login sessions, shopping carts, and personalized experiences.

### Q6. What is Cookie?

A cookie is a small piece of data that a web server sends to a client's browser and is stored on the client's device. It is used to store information about the user or their interaction with a website.

When a user visits a website, the server can include one or more cookies in the response headers. The client's browser then stores these cookies and includes them in subsequent requests to the same website. This allows the server to recognize and remember the user's preferences, session state, or other relevant information.

Cookies can have various attributes, such as a name, value, expiration date, domain, and path. The name-value pair typically contains the data that the server wants to store. The expiration date determines how long the cookie remains valid and stored on the client's device. The domain and path specify the scope or the specific website and URL paths for which the cookie is valid.

Cookies are commonly used for various purposes, including session management, user authentication, tracking user behavior, personalization, and storing user preferences. They provide a way for websites to maintain stateful interactions with users across multiple requests and enable a more personalized and convenient browsing experience.

### Q7. What is the difference between Session and Cookie?

The main differences between Session and Cookie are as follows:

1. Purpose: A session is used to maintain stateful communication between a web server and a client over multiple requests and responses within an HTTP protocol-based application. It allows the server to associate a set of data with a particular client. On the other hand, a cookie is a small piece of data that a web server sends to a client's browser and is stored on the client's device. It is used to store information about the user or their interaction with a website.

2. Storage Location: Session data is stored on the server-side. The server generates a unique session ID and associates it with the corresponding data stored on the server. This session ID is typically sent to the client as a cookie or included in the URL. In contrast, cookies are stored on the client-side. The client's browser stores the cookie data and sends it back to the server with subsequent requests to the same website.

3. Data Capacity: Sessions can store a larger amount of data compared to cookies. Since session data is stored on the server, the actual data stored in the session can be more extensive. Cookies, on the other hand, have size limitations (usually around 4KB) imposed by browsers.

4. Security: Sessions are generally considered more secure than cookies. Session data is stored on the server and only the session ID is sent to the client. This reduces the risk of exposing sensitive information. Cookies, being stored on the client-side, can be potentially accessed or manipulated by the user or other scripts running on the client's device.

5. Expiration: Sessions can have an expiration time or can be set to expire when the user closes the browser. Cookies have an expiration date and time specified by the server when they are created. They can either be persistent cookies (stored on the client device for a longer period) or session cookies (stored temporarily and deleted when the browser is closed).

In summary, sessions are server-side mechanisms used to maintain stateful communication, while cookies are client-side storage for storing small pieces of data. Sessions offer more storage capacity, better security, and are managed by the server, while cookies are limited in size, stored on the client-side, and can be accessed or modified by the client.

### Q8. How do we use session and cookie to keep user information across the the application?

To keep user information across the application using sessions and cookies, you can follow these steps:

1. When a user logs in or provides their information, authenticate the user and store their relevant information in a session object on the server-side. The session object is typically accessible through a session ID.

2. Generate a session ID and send it to the client-side as a cookie. The cookie should have a unique name and value representing the session ID.

3. On subsequent requests from the client, the session ID will be sent back to the server as a cookie. Retrieve the session object associated with the session ID from the server-side storage.

4. Access the user information stored in the session object to personalize the user's experience or perform any necessary operations.

5. When the user logs out or the session expires, remove the session object from the server-side storage and invalidate the session ID.

By using sessions and cookies in this manner, you can maintain user information across multiple requests and ensure that the user remains authenticated throughout their session. The session object stored on the server allows you to securely store and retrieve user-specific data, while the cookie stored on the client-side provides a means for the client to identify and communicate the session ID with the server.

### Q9. What is JWT?

JWT stands for JSON Web Token. It is an open standard (RFC 7519) that defines a compact and self-contained way to securely transmit information between parties as a JSON object.

JWTs are often used for authentication and authorization purposes in web applications and APIs. The token contains a set of claims or statements that assert certain information about the user or entity, such as their identity, roles, or permissions. It consists of three parts: header, payload, and signature.

1. Header: The header specifies the algorithm used to sign the token and typically includes the token type, which is "JWT" in this case.

2. Payload: The payload carries the claims or statements about the user. These claims can include standard claims defined by the JWT specification (e.g., "iss" for issuer, "exp" for expiration time) or custom claims specific to the application.

3. Signature: The signature is created by combining the encoded header, encoded payload, and a secret or private key. It verifies the integrity of the token and ensures that it has not been tampered with.

JWTs are commonly used for authentication by exchanging them between a client and a server. When a user logs in, the server generates a JWT and sends it back to the client. The client includes the JWT in subsequent requests as an authorization header or within the request payload. The server validates the JWT's signature and extracts the claims to authenticate and authorize the user.

JWTs are stateless, meaning that the server does not need to store session information. Instead, the necessary information is embedded within the token itself, reducing the reliance on server-side storage and allowing for scalable and distributed systems.

Overall, JWTs provide a secure and compact way to transmit information between parties, facilitating stateless authentication and authorization in web applications and APIs.

### Q10. What is the spring security filter?

In Spring Security, a filter is a fundamental component used to process incoming requests and outgoing responses. Spring Security provides a set of predefined filters that work together to handle various security-related tasks within a web application.

Spring Security filters are responsible for tasks such as authentication, authorization, session management, request validation, and more. Each filter has a specific responsibility and is executed in a specific order defined by the Spring Security filter chain.

The Spring Security filter chain is a sequence of filters that intercepts incoming requests and performs security-related operations. The filters are configured and arranged in a specific order based on their functionality and requirements.

Some of the commonly used Spring Security filters include:

1. AuthenticationFilter: Handles the authentication process and verifies user credentials.

2. AuthorizationFilter: Checks whether the authenticated user has the required permissions to access a specific resource or perform a certain action.

3. SessionManagementFilter: Manages user sessions, handles session creation, invalidation, and tracks session state.

4. CsrfFilter: Protects against cross-site request forgery (CSRF) attacks by validating CSRF tokens.

5. LogoutFilter: Handles user logout functionality and clears the user's session.

6. ExceptionTranslationFilter: Translates exceptions thrown during the authentication and authorization process into meaningful responses.

Developers can also create custom filters by extending Spring Security filter classes or implementing the `javax.servlet.Filter` interface. This allows for additional customization and the inclusion of custom security-related logic within the filter chain.

Overall, Spring Security filters form an integral part of the security infrastructure in a Spring-based application. They work together to enforce security policies, protect resources, and handle various security-related tasks during request processing.

### Q11. decribe how do JWT work(slides 里有图， 26页)


JWT (JSON Web Token) works through a simple and self-contained structure that allows secure transmission of information between parties. Here's an overview of how JWTs work:

1. Issuing a Token: When a user authenticates or a server generates a token, a JWT is created. It consists of three parts: header, payload, and signature. The header defines the token's type and the signing algorithm used. The payload contains claims, which are statements about the user or entity (e.g., user ID, roles, or permissions). The payload is then encoded using Base64Url encoding.

2. Signing the Token: To ensure the integrity of the token and prevent tampering, the encoded header, encoded payload, and a secret or private key are combined and encrypted to create the signature. The signature guarantees that the token hasn't been altered since it was issued.

3. Transmitting the Token: The JWT is transmitted between parties (e.g., client and server) typically as an HTTP Authorization header with the value "Bearer" followed by the JWT. Alternatively, it can be sent as a part of the request payload or query parameters.

4. Verifying the Token: When a recipient receives the JWT, they can verify its authenticity and extract the claims. The recipient uses the same secret or public key to decode the signature and validate that it matches the encoded header and payload. If the signature verification succeeds, the recipient knows that the token is valid and hasn't been tampered with.

5. Extracting Claims: Once the token's signature is validated, the recipient can extract the claims from the payload. These claims contain information about the user or entity, such as their identity, roles, or other relevant details. The recipient can use these claims to authenticate and authorize the user's access to resources or perform specific actions.

6. Token Expiration and Renewal: JWTs often include an expiration time (exp claim) to ensure they are only valid for a certain period. After expiration, the token is no longer considered valid, and the recipient should request a new token or force the user to re-authenticate.

7. Statelessness and Scalability: JWTs are stateless, meaning that the server doesn't need to store session information. All necessary information is contained within the token itself, enabling scalability and facilitating the use of distributed systems.

By using JWTs, applications can securely transmit and exchange information between parties, enabling stateless authentication and authorization. JWTs provide a compact and flexible approach to implement token-based authentication and facilitate secure communication in web applications and APIs.


### Q12. Do you use any Encoder to encode Password?

As an AI language model, I don't have direct access to a specific implementation or codebase. However, in general, when it comes to encoding or hashing passwords for secure storage, it is recommended to use strong cryptographic hash functions specifically designed for password hashing. Examples of commonly used algorithms for password encoding include bcrypt, PBKDF2, and Argon2.

These algorithms are designed to be computationally expensive and slow down the hashing process, making it harder for attackers to brute-force or crack passwords. They also incorporate features like salting (adding random data to the password before hashing) to further enhance security.

It's important to note that password encoding is a security-sensitive task, and it's generally recommended to rely on well-established and widely reviewed password hashing functions rather than attempting to implement custom encoding mechanisms. Frameworks and libraries like Spring Security provide built-in support for secure password encoding using recommended algorithms.


### Q13. What is UserDetailService?AuthenticationProvider?AuthenticationManager?  AuthenticationFilter?(把这几个名字看熟悉也行)

1. UserDetailService: `UserDetailsService` is an interface provided by Spring Security that is used to retrieve user details and build a `UserDetails` object. It acts as a bridge between the application's user repository (database, LDAP, etc.) and Spring Security's authentication mechanisms. It typically has a method `loadUserByUsername()` that fetches user details based on the provided username or identifier.

2. AuthenticationProvider: `AuthenticationProvider` is an interface in Spring Security that performs the authentication process. It takes an `Authentication` object (usually a `UsernamePasswordAuthenticationToken`) as input and returns a fully authenticated `Authentication` object if the authentication is successful. It encapsulates the logic to verify user credentials, such as checking passwords or integrating with an external authentication provider. Spring Security provides various built-in implementations of `AuthenticationProvider` that handle different authentication mechanisms.

3. AuthenticationManager: `AuthenticationManager` is an interface in Spring Security that is responsible for managing the authentication process. It typically delegates the authentication request to one or more `AuthenticationProvider` instances. The `AuthenticationManager` attempts to authenticate the `Authentication` object using the configured providers in the order they were added. If one of the providers successfully authenticates the request, the `AuthenticationManager` returns a fully authenticated `Authentication` object. Developers can create custom `AuthenticationManager` implementations to suit their authentication requirements.

4. AuthenticationFilter: `AuthenticationFilter` is a component provided by Spring Security that intercepts the authentication request and handles the initial authentication process. It typically extends the abstract class `AbstractAuthenticationProcessingFilter`. The `AuthenticationFilter` extracts authentication credentials from the incoming request (e.g., username/password or token), creates an `Authentication` object, and delegates it to the `AuthenticationManager` for authentication. Once the authentication process is complete, the `AuthenticationFilter` either allows the request to proceed or redirects to a success or failure handler based on the authentication result.

These components work together to facilitate the authentication process in Spring Security. The `UserDetailsService` retrieves user details, the `AuthenticationProvider` verifies credentials, the `AuthenticationManager` manages the authentication process, and the `AuthenticationFilter` intercepts requests and initiates the authentication flow.

### Q14. What is the disadvantage of Session? how to overcome the disadvantage?

Sessions have a few disadvantages, including:

1. Scalability: Sessions require server-side storage to store session data. As the number of active sessions increases, it can put a strain on server resources and impact scalability. Storing session data in a centralized location can also introduce a single point of failure.

2. Server resource consumption: Session data is typically stored in memory on the server. Large session objects or a high number of active sessions can consume significant server memory, affecting the overall performance of the application.

3. Server affinity: By default, sessions rely on server affinity, meaning that once a user's session is established on a specific server, subsequent requests from that user need to be routed to the same server. This can limit load balancing and failover capabilities in a distributed system.

To overcome these disadvantages, alternative approaches can be considered:

1. Stateless Authentication: Instead of relying on server-side sessions, implement stateless authentication mechanisms like JWT (JSON Web Tokens). JWTs store the necessary user information securely within the token itself, eliminating the need for server-side session storage. Stateless authentication allows for better scalability and avoids the drawbacks associated with server-side sessions.

2. Distributed Caching: If session storage is still required, consider using distributed caching solutions like Redis or Memcached. These caching systems allow session data to be stored in a distributed manner, reducing the load on individual servers and improving scalability.

3. Database-backed Sessions: Rather than storing session data in memory, consider using a database-backed session store. This approach offloads session storage to a database, which can handle large amounts of data and distribute the load across multiple servers if needed.

4. Cookie-based Sessions: Instead of relying on server-side sessions, store minimal session data on the client-side as an encrypted cookie. The cookie can contain a session identifier that allows the server to retrieve session data from a central data store or database.

Overall, the choice of overcoming the disadvantages of sessions depends on the specific requirements and constraints of the application. Stateless authentication, distributed caching, database-backed sessions, and cookie-based sessions are some approaches that can address the scalability and resource consumption issues associated with traditional server-side sessions.

### Q15. how to get value from application.properties?

To retrieve values from the `application.properties` file in a Spring application, you can use the `@Value` annotation or the `Environment` object.

1. Using the `@Value` annotation:
    - Annotate a field or method parameter with `@Value("${property.key}")`, where `"${property.key}"` is the placeholder for the property key defined in the `application.properties` file.
    - Spring will automatically inject the value from the `application.properties` file into the annotated field or method parameter.

Example:
```java
import org.springframework.beans.factory.annotation.Value;

// ...

@Value("${my.property}")
private String myProperty;
```
In this example, the value of the property `my.property` from the `application.properties` file will be injected into the `myProperty` field.

2. Using the `Environment` object:
    - Autowire the `Environment` object into your component or bean.
    - Use the `getProperty("property.key")` method to retrieve the value of a specific property key.

Example:
```java
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.env.Environment;

// ...

@Autowired
private Environment environment;

public void someMethod() {
    String myProperty = environment.getProperty("my.property");
    // Use the value of myProperty as needed
}
```
In this example, the `Environment` object is autowired, and the `getProperty()` method is used to retrieve the value of the `my.property` key from the `application.properties` file.

Make sure that you have the `application.properties` file in the correct location (usually in the classpath root) and that the properties are defined correctly with the appropriate key-value pairs.

Note: If you're using newer versions of Spring Boot or have a `application.yml` configuration file instead, the same approaches can be used, just replacing the property key syntax accordingly.

### Q16. What is the role of configure(HttpSecurity http) and configure(AuthenticationManagerBuilder auth)?

In a class that extends `WebSecurityConfigurerAdapter` in Spring Security, you typically override two methods: `configure(HttpSecurity http)` and `configure(AuthenticationManagerBuilder auth)`.

1. `configure(HttpSecurity http)`:
    - The `configure(HttpSecurity http)` method is responsible for configuring the security rules and access restrictions for different URL patterns within your application.
    - It defines how the application handles HTTP requests and applies security measures such as authentication, authorization, and request filtering.
    - Within this method, you can specify which URLs require authentication, define access control rules, configure login and logout behavior, enable CSRF protection, set up session management, and more.
    - By customizing this method, you can define how different parts of your application should be secured and what actions are allowed or denied to different types of users or roles.

2. `configure(AuthenticationManagerBuilder auth)`:
    - The `configure(AuthenticationManagerBuilder auth)` method is responsible for configuring the authentication mechanism used by Spring Security.
    - It defines how user credentials are verified and how authentication is performed.
    - Within this method, you can specify the authentication provider, such as in-memory user details, JDBC-based authentication, or external authentication providers.
    - You can configure the authentication process by setting up user details, password encoding, user roles, and any additional authentication mechanisms like LDAP or OAuth.
    - By customizing this method, you define how Spring Security authenticates users and what user information sources it should use.

Both methods play crucial roles in customizing the behavior of Spring Security within your application. `configure(HttpSecurity http)` focuses on configuring security rules and access restrictions, while `configure(AuthenticationManagerBuilder auth)` focuses on configuring the authentication mechanism. These methods work together to define the security policies and mechanisms that determine how your application handles user authentication, authorization, and access control.


### Q17. What is Spring security authentication and authorization?

In Spring Security, authentication and authorization are two fundamental concepts that work together to ensure the security of a web application.

1. Authentication:
    - Authentication is the process of verifying the identity of a user or entity.
    - In Spring Security, the authentication process involves validating the credentials provided by the user to establish their identity.
    - The most common form of authentication is username-password authentication, where the user provides their username and password, which are then verified against a user repository (such as a database) to determine if they are valid.
    - Spring Security provides various authentication mechanisms, including form-based authentication, HTTP Basic and Digest authentication, LDAP authentication, and integration with external authentication providers like OAuth and OpenID Connect.
    - Once the authentication is successful, a user is considered authenticated, and they are granted access to the protected resources of the application.

2. Authorization:
    - Authorization is the process of determining whether an authenticated user or entity has the necessary permissions to access a specific resource or perform a particular action.
    - Spring Security provides a robust authorization framework that allows developers to define access control rules and restrictions.
    - Authorization in Spring Security is based on roles and privileges assigned to users or user groups.
    - Roles represent a collection of permissions, and users can be assigned one or more roles.
    - Privileges define specific actions or operations that users can perform within the application.
    - Access control rules can be defined using expressions, annotations, or configuration files, specifying which roles or privileges are required to access certain URLs, methods, or resources.
    - Spring Security also supports method-level security, where specific methods can be secured based on the user's roles or privileges.

Together, authentication and authorization form the foundation of securing a Spring-based application. Authentication verifies the user's identity, while authorization determines what the authenticated user can and cannot do within the application. By enforcing these two security mechanisms, Spring Security helps protect sensitive resources, ensure data integrity, and prevent unauthorized access to critical functionalities.


### Q18.

`springboot-redbook-08_04_SpringSecurity_DB`